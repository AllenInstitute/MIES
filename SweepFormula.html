<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>The Sweep Formula Module &#8212; MIES Igor (main) Release_2.9_20250502-727-gbe223af4b documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=6d6ea0d4" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css?v=a781dc68" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css?v=cbca8d48" />
    <link rel="stylesheet" type="text/css" href="_static/sphinxcontrib-images/LightBox2/lightbox2/dist/css/lightbox.min.css?v=6e7d0de0" />
    <link rel="stylesheet" type="text/css" href="_static/sphinxcontrib-images/LightBox2/lightbox2-customize/pointer.css?v=c97663ff" />
    
    <script src="_static/documentation_options.js?v=f265e7a6"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/sphinxcontrib-images/LightBox2/lightbox2/dist/js/lightbox-plus-jquery.min.js?v=f0ca4bb6"></script>
    <script src="_static/sphinxcontrib-images/LightBox2/lightbox2-customize/jquery-noconflict.js?v=12818e64"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Labnotebook descriptions" href="labnotebook-descriptions.html" />
    <link rel="prev" title="Automatic test pulse tuning" href="auto_testpulse_tuning.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="labnotebook-descriptions.html" title="Labnotebook descriptions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="auto_testpulse_tuning.html" title="Automatic test pulse tuning"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">MIES Igor (main) Release_2.9_20250502-727-gbe223af4b documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="user.html" accesskey="U">User documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">The Sweep Formula Module</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="the-sweep-formula-module">
<span id="sweepformula"></span><h1>The Sweep Formula Module<a class="headerlink" href="#the-sweep-formula-module" title="Link to this heading">¶</a></h1>
<p>The Sweep Formula Module in <cite>MIES_Sweepformula.ipf</cite> is intended to be used from
the SF tab in the BrowserSettingsPanel (BSP). It is useful for analyzing a
range of sweeps using pre-defined functions. The backend parses a formula into
a <a class="reference external" href="http://jsonlogic.com/">JSON logic</a> like pattern which in turn is analyzed
to return a wave for plotting.</p>
<section id="preprocessing">
<h2>Preprocessing<a class="headerlink" href="#preprocessing" title="Link to this heading">¶</a></h2>
<p>The entered code in the notebook is preprocessed. The preprocessor
removes comments before testing the code for the ` vs ` operator after which
it is passed to the formula parser.
Comments start with a <cite>#</cite> character and end at the end of the current line.</p>
</section>
<section id="formula-parser">
<h2>Formula Parser<a class="headerlink" href="#formula-parser" title="Link to this heading">¶</a></h2>
<p>In order for a formula to get executed, it has to be analyzed. This assures
that the correct order of calculations is used. The approach for solving this
is using a token based state machine. We virtually insert one character at a
time from left to right into the state machine. Usually, a character is
collected into a buffer. At some special characters like a <cite>+</cite> sign, the state
changes from collect to addition. If a state changes, a new evaluation group is
created which is represented with a JSON object who’s (single) member is the
operation. The member name is the operation and the value is an ordered array
of the operands. To ensure that multiplication is executed before addition to
get <cite>1+2*3=7</cite> and not <cite>1+2*3=9</cite> the states have a priority. Higher order states
cause the operation order to switch. The old operation becomes part of the new
operation. In this context, when the first array or function argument separator <cite>,</cite>
is parsed on a level, it is treated as higher order operations because it creates
a new array.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;+&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;*&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="mi">2</span><span class="p">,</span>
<span class="w">        </span><span class="mi">3</span>
<span class="w">      </span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Arrays start with a square bracket <cite>[</cite> and end with a <cite>]</cite>. Subsequent array elements are
separated by a <cite>,</cite>. In a series of arrays like <cite>[1, 2], [3, 4], [5, 6]</cite> the <cite>,</cite> after
the <cite>]</cite> is enforced by the parser. Arrays can be part of arrays. Since at its core very
formula input is an array the series of arrays <cite>[1, 2], [3, 4], [5, 6]</cite> is implicitly
a 2-dimensional array: <cite>[[1, 2], [3, 4], [5, 6]]</cite>. The same applies for simple inputs like
<cite>1</cite>, which is implicitly treated as 1-dimensional array: <cite>[1]</cite>. The input <cite>[[1]]</cite> instead
is treated as 1x1 2-dimensional array.
Arrays are special as
also function arguments contain array elements. Therefore, an array can also
simply be created by omitting the array brackets and only using element
separators similar as in functions. The function <cite>max(1,2)</cite> is therefore
treated the same as <cite>max([1,2])</cite>. Arrays can represent data and functions
evaluate to arrays. Arrays can be of arbitrary size and can also be
concatenated as in <cite>max(0,min(1,2),1)</cite>.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;max&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;min&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="mi">1</span><span class="p">,</span>
<span class="w">        </span><span class="mi">2</span>
<span class="w">      </span><span class="p">]</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="mi">1</span>
<span class="w">  </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A number can be entered as <cite>1000</cite>, <cite>1e3</cite>, or <cite>10.0e2</cite>. It is always stored as a
numeric value and not as string. The formula parser treats everything that is
not parsable but matches alphanumeric characters (excluding operations) to a
string as in <cite>a_string</cite>. White spaces are ignored throughout the
formula which means that strings do <em>not</em> need to get enclosed by <cite>“</cite>. In fact,
a <cite>“</cite> is an disallowed character.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">[</span>
<span class="w">  </span><span class="mi">1000</span><span class="p">,</span>
<span class="w">  </span><span class="s2">&quot;a_string&quot;</span>
<span class="p">]</span>
</pre></div>
</div>
<p>A function is defined as a string that is directly followed by an opening
parenthesis. The parenthesis token causes to force a collect state until all
parentheses are closed.</p>
<p>Everything that is collected in a buffer is sent back to the function via
recursive execution. The formula parser only handles elements inside one
recursion call that are linearly combinable like <cite>1*2+3*4</cite>. If same operations
follow each other, they are concatenated into the same array level as for
<cite>1+2+3+4</cite>.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;+&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="mi">4</span>
<span class="w">  </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;+&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;*&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="mi">1</span><span class="p">,</span>
<span class="w">        </span><span class="mi">2</span>
<span class="w">      </span><span class="p">]</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;*&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="mi">3</span><span class="p">,</span>
<span class="w">        </span><span class="mi">4</span>
<span class="w">      </span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The formula is sent to a preparser that checks for the correct
amount of brackets and converts multi-character operations to their multi-character
UTF-8 representations like <cite>…</cite> to <cite>…</cite>. It should be noted that an
operation consists of one UTF-8 character. Functions on the other hand can
consist of an arbitrary length of alphanumeric characters. The corresponding
function for the above operation is <cite>range()</cite>.</p>
</section>
<section id="formula-executor">
<h2>Formula Executor<a class="headerlink" href="#formula-executor" title="Link to this heading">¶</a></h2>
<p>The formula executor receives a JSON id. It can only evaluate a specific
structure of a formula which means for usual cases that it should start with an
object that contains <em>one</em> operation. Operations are evaluated via recursive
calls to the formula executor at different paths. This ensures that the formula
is evaluated from the last element to the first element. The formula in the
above example <cite>1*2+3*4</cite> is therefore parsed to</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;+&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;*&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="mi">1</span><span class="p">,</span>
<span class="w">        </span><span class="mi">2</span>
<span class="w">      </span><span class="p">]</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;*&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="mi">3</span><span class="p">,</span>
<span class="w">        </span><span class="mi">4</span>
<span class="w">      </span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The execution follows these steps:</p>
<ol class="arabic simple">
<li><p>evaluate <cite>/</cite> to <cite>+</cite> operation, call <cite>+</cite></p></li>
<li><p>called from <cite>+</cite> operation -&gt; evaluate <cite>/+</cite> array to array with two elements</p></li>
<li><p>evaluate <cite>/+/0</cite> to <cite>*</cite> operation with an array argument with two elements 1, 2</p></li>
<li><p>called from <cite>*</cite> operation -&gt; evaluate <cite>/+/0/*</cite> array to wave {1, 2}</p></li>
<li><p><cite>*</cite> operation is applied to wave {1, 2}, returning wave {2}</p></li>
<li><p>insert wave {2} as first element of array from step 2</p></li>
<li><p>evaluate <cite>/+/1</cite> to * operation with an array argument with two elements 3, 4</p></li>
<li><p>called from <cite>*</cite> operation -&gt; evaluate <cite>/+/0/*</cite> array to wave {3, 4}</p></li>
<li><p><cite>*</cite> operation is applied to wave {3, 4}, returning wave {12}</p></li>
<li><p>insert wave {12} as second element of array from step 2</p></li>
<li><p><cite>+</cite> operation is applied to wave {2, 12} returning wave {14}</p></li>
</ol>
<p>At the time of an evaluation, the maximum depth of an array is
four dimensions as Igor Pro supports only four dimensions. This implies that on
recursive evaluation of multi dimensional arrays the sub arrays can be
three dimensional at best.</p>
<section id="array-evaluation">
<h3>Array Evaluation<a class="headerlink" href="#array-evaluation" title="Link to this heading">¶</a></h3>
<p>The array evaluation supports numeric and text data. The interpretation of the JSON arrays as
text data is preferred. This means that <cite>[“NaN”]</cite> returns a one element text wave <cite>{“NaN”}</cite>,
whereas <cite>[1, “NaN”]</cite> returns a two element numeric wave <cite>{1, NaN}</cite>. If one element can not be
parsed as string then it is assumed that the array contains numeric data.
The JSON null element is only allowed for the topmost array as the parser inserts it for
operation with no argument like e.g. <cite>select()</cite>. For sub arrays null elements <cite>[null]</cite>
are invalid and result in an error.</p>
<p>If the topmost array is empty <cite>[]</cite> an empty numeric wave with zero size is returned.
When checked in operation code the wave size should be checked before the wave type.</p>
<p>If the current array evaluated is of size one, then
the wave note is transferred from the subArray to the current array. This is important for the case where the element of
the current array is an JSON object, thus an operation, and the operation result is a single value with meta data in the wave.</p>
</section>
<section id="formula-executor-limitations">
<h3>Formula Executor Limitations<a class="headerlink" href="#formula-executor-limitations" title="Link to this heading">¶</a></h3>
<p>Mixed data types in arrays are not supported as this JSON property is hard to translate to Igor Pro data
storage in waves.</p>
</section>
</section>
<section id="internal-data-layout">
<h2>Internal Data Layout<a class="headerlink" href="#internal-data-layout" title="Link to this heading">¶</a></h2>
<p>The data is stored internally in persistant wave reference waves in a data folder, e.g.
<cite>root:MIES:HardwareDevices:Dev1:Databrowser:FormulaData:</cite>. The reason is that operation like <cite>data(…)</cite>
should be able to return multiple independent sweep data waves. These can be returned through a
wave reference wave. Each wave referenced contains numeric or text data.
The formula executor works on the JSON data that was created by the formula parser only.
This data is by definition either an object (operation), numeric or a textual.
If an operation like <cite>data(…)</cite> returns sweep data of multiple sweeps in a persistent wave reference wave
for the formula executor a single element text wave is created.
This text wave encodes a marker and the path to the wave reference wave in the first element.
The wave reference wave is resolved by wrapper functions when calling the formula executor,
such that the formula executor works only with the data wave(s).</p>
<p>Wrapper functions are:</p>
<ul class="simple">
<li><p><cite>SF_GetArgument</cite>: retrieves an operation argument, returns a wave reference wave. If in the JSON from the parser the argument consists of ‘direct’ data like an array then it is automatically converted to a wave reference wave with one element that refers to the data wave.</p></li>
<li><p><cite>SF_GetArgumentSingle</cite>: retrieves an operation argument expecting only a single data wave. Returns the data wave.</p></li>
<li><p><cite>SF_GetArgumentTop</cite>: retrieves all operation arguments as an array, returns a wave reference wave.</p></li>
<li><p><cite>SF_GetOutputForExecutor</cite>: Takes a wave reference wave as input and creates a single element text wave for returning further to the formula executor.</p></li>
<li><p><cite>SF_GetOutputForExecutorSingle</cite>: Takes a data wave as input, creates a single element wave reference wave referring to the data wave and creates text wave for returning further to the formula executor.</p></li>
</ul>
<p>The wrapper function imply that the formula executor is never called directly from operation code.
Also directly parsing the JSON is not allowed in operation code because every argument could be another operation or multi dimensional array etc.</p>
</section>
<section id="debugging-formula-execution">
<h2>Debugging Formula Execution<a class="headerlink" href="#debugging-formula-execution" title="Link to this heading">¶</a></h2>
<p>By default only the currently used wave reference waves are persistent. For debugging the execution the <cite>SWEEPFORMULA_DEBUG</cite> define can be set:
<cite>#define SWEEPFORMULA_DEBUG</cite>.
When set all data waves and wave reference waves are stored persistently in the sweepformula working data folder that are created during the execution.
The naming scheme is as follows: “source_pointOfCreation” with</p>
<dl class="simple">
<dt>source</dt><dd><p>typically the name of the operation or “ExecutorSubArrayEvaluation”</p>
</dd>
</dl>
<p>pointOfCreation:</p>
<dl class="simple">
<dt>output</dt><dd><p>wave reference wave output of operation</p>
</dd>
<dt>dataInput</dt><dd><p>data wave of direct data from JSON</p>
</dd>
<dt>refFromuserInput</dt><dd><p>wave reference wave automatically created to for data wave of direct data from JSON</p>
</dd>
<dt>return_argX_</dt><dd><p>data wave(s) returned by an operation, X counts the data waves aka index in the associated wave reference wave</p>
</dd>
<dt>argTop</dt><dd><p>prefix for the upper tags, added when data was parsed from the top level, used e.g. by <cite>integrate(1, 2)</cite></p>
</dd>
</dl>
<p>The final wave name might be suffixed by a number guaranteeing unique wave names when multiple times the same operation was called.</p>
</section>
<section id="operations">
<h2>Operations<a class="headerlink" href="#operations" title="Link to this heading">¶</a></h2>
<p>In the context of the formula executor, different operations and functions are
defined. Some of them are <em>MIES</em> specific, some of them are wrappers to Igor
Pro operations or functions, some borrowed from other languages and there are
also the simple, trivial operations. This section should give a list of the
available operations and give a look into how they are meant to be used</p>
<p>The trivial operations are <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>. They are defined for all
available dimensions and evaluate column based.</p>
<p>They can be used for evaluating</p>
<ol class="arabic simple">
<li><p>scalars with 1d waves as in <cite>1 + [1, 2] = [1, 1] + [1, 2] = [2, 3]</cite></p></li>
<li><p>1d waves with 1d waves as in <cite>[1, 2] + [3, 4] = [4, 6]</cite></p></li>
<li><p>1d waves with 2d waves as in <cite>[1, 2] + [[3, 4], [5, 6]] = [[1 + 3, 2 + 5], [NaN + 4, NaN + 6]] = [[4, 7], [NaN, NaN]]</cite></p></li>
<li><p>2d waves with 2d waves as in <cite>[[1, 2], [3, 4]] + [[5, 6], [7, 8]] = [[6, 8], [10, 12]]</cite></p></li>
</ol>
<p>The size in each dimension is expanded to match the maximum array size. The maximum array size is determined by the required maximum dimensions of the elements in the topmost array.
An array element can be a number, a string, an array or an operation. A number or string a scalar. An sub array or operaton result is scalar if it returns a single element.
The expansion is filled with for numeric waves with <cite>NaN</cite> or for textual waves with <cite>“”</cite>.
In the special case of a scalar element, the value is expanded to the full size and dimensions of the expanded arrays size.
This means that in our first example, 1 is scalar and is internally expanded to an array of size 2 because the second operand determines the maximum size of 2:
<cite>1 + [1, 2] == [1, 1] + [1, 2]</cite>.
On the other hand in the third example above the first arrays size is expanded but not its value as it is not a scalar.
The array size expansion and scalar elements expansion is applied recursively for more dimensions.
Note that operations in array elements may return multi dimensional sub arrays that lead to an overall array expansion that is greater as the formula input suggests.</p>
</section>
<section id="statistical-operations">
<h2>Statistical Operations<a class="headerlink" href="#statistical-operations" title="Link to this heading">¶</a></h2>
<section id="min-and-max">
<h3>min and max<a class="headerlink" href="#min-and-max" title="Link to this heading">¶</a></h3>
<p><cite>min</cite> and <cite>max</cite> return the minimum and maximum of an array.
The operation takes 1 to N arguments. The input data must be 1d or 2d, numeric and have at least one data point.
The operations work column based, such that for each column e.g. the maximum of all row values is determined. An 2d input array of size MxN is returned as 1d array of the size N.
When called with a single argument the operation accepts multiple data waves.
For this case the operation is applied on each input data wave independently and returns the same number of data waves.
The returned data type is <cite>SF_DATATYPE_MIN</cite> or <cite>SF_DATATYPE_MAX</cite>.
If input data type is <cite>SF_DATATYPE_SWEEP</cite> from the data operation the sweep meta data is transferred to the returned data waves.
The default suggested x-axis values for the formula plotter are sweep numbers.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>min<span class="o">([[</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span><span class="o">]</span>,<span class="o">[</span><span class="m">3</span>,<span class="w"> </span><span class="m">4</span><span class="o">]])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span><span class="o">]</span>

max<span class="o">(</span>min<span class="o">([[</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span><span class="o">]</span>,<span class="o">[</span><span class="m">3</span>,<span class="w"> </span><span class="m">4</span><span class="o">]]))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="m">2</span><span class="o">]</span>

min<span class="o">(</span><span class="m">2</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">2</span><span class="o">]</span>
</pre></div>
</div>
</section>
<section id="avg-and-mean">
<h3>avg and mean<a class="headerlink" href="#avg-and-mean" title="Link to this heading">¶</a></h3>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>avg<span class="o">(</span>array<span class="w"> </span>data<span class="o">[</span>,<span class="w"> </span>string<span class="w"> </span>mode<span class="o">])</span>
</pre></div>
</div>
<p><cite>avg</cite> and <cite>mean</cite> are synonyms for the same operation.
They calculate the arithmetic average <span class="math notranslate nohighlight">\(\frac{1}{n}\sum_i{x_i}\)</span>.</p>
<p>data: input data wave(s) or array of datasets</p>
<dl class="simple">
<dt>mode: optional parameter that defines in which direction the average is applied.</dt><dd><ul class="simple">
<li><p><cite>in</cite> default, applies the average over each input data wave. In this mode the operation returns the same number of waves as input waves were specified. Each output wave contains a single data point. If input data type is <cite>SF_DATATYPE_SWEEP</cite> from the data operation the sweep meta data is transferred to the returned data waves. The default suggested x-axis values for the formula plotter are sweep numbers.</p></li>
<li><p><cite>over</cite> averages over all input data waves. In this mode the operation returns a single wave. <cite>NaN</cite> values in input waves are ignored in the average calculation. A trace generated from the returned wave will be shown as topmost trace in the default color for averaged data.</p></li>
<li><p><cite>group</cite> accepts an array of datasets as the first argument. The datasets can have different numbers of elements. The average calculation is performed over the n-th elements of each dataset where they exist; for each index, only datasets that have an element at that position are included in the average. For example, if you have three datasets of sweep data: 1, 2, 3; 4, 5, 6; and 7, 8, 9, each prepared in their own variable (<cite>sweepset0</cite>, <cite>sweepset1</cite>, <cite>sweepset2</cite>), then <cite>avg([$sweepset0, $sweepset1, $sweepset2], group)</cite> averages sweep 1, 4, 7 for the first element, 2, 5, 8 for the second, and 3, 6, 9 for the third. If the datasets have different lengths, the result will have the same length as the longest input dataset, and for each position, only the available elements are averaged. The input datasets can be of any type and do not need to be sweep data. The first argument must contain at least two datasets. Meta data transfer: If the first element dataset in the array contains meta data, that meta data is transferred to the result. If the first element has no meta data, then no meta data is transferred. The structure and content of the meta data depend on the type of the first dataset; for example, sweep datasets may have sweep-specific meta data, while other types may have none or different structures. If the meta data is incompatible with the result, only the compatible parts are transferred.</p></li>
</ul>
</dd>
</dl>
<p>When an argument is of the select type then automatically data is applied to implicitly convert to sweep data.
This conversion is also applied in the <cite>group</cite> mode for array elements that are of the select type.</p>
<p>The returned data type is <cite>SF_DATATYPE_AVG</cite>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>avg<span class="o">([</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span><span class="o">])</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">2</span><span class="o">]</span>

avg<span class="o">(</span>data<span class="o">(</span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span>ST<span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD<span class="o">)</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">)))</span>,<span class="w"> </span>over<span class="o">)</span>

avg<span class="o">(</span>data<span class="o">(</span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span>ST<span class="o">)))</span>,<span class="w"> </span><span class="k">in</span><span class="o">)</span>

avg<span class="o">([</span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span>E1<span class="o">))</span>,<span class="w"> </span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span>E2<span class="o">))]</span>,<span class="w"> </span>group<span class="o">)</span>

avg<span class="o">([</span><span class="nv">$sweepset0</span>,<span class="w"> </span><span class="nv">$sweepset1</span><span class="o">]</span>,<span class="w"> </span>group<span class="o">)</span><span class="w">  </span><span class="c1"># meta data from $sweepset0 is transferred to the result</span>
</pre></div>
</div>
</section>
<section id="extract">
<h3>extract<a class="headerlink" href="#extract" title="Link to this heading">¶</a></h3>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>extract<span class="o">(</span>datasets,<span class="w"> </span>index<span class="o">)</span>
</pre></div>
</div>
<p><cite>extract</cite> takes datasets as first argument and an index number as second argument. It returns the dataset from position index.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">sweep2DA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>extract<span class="o">(</span>data<span class="o">(</span><span class="k">select</span><span class="o">(</span>selsweeps<span class="o">(</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span><span class="o">)</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>DA<span class="o">)))</span>,<span class="w"> </span><span class="m">1</span><span class="o">)</span>
</pre></div>
</div>
</section>
<section id="root-mean-square">
<h3>root mean square<a class="headerlink" href="#root-mean-square" title="Link to this heading">¶</a></h3>
<p><cite>rms</cite> calculates the root mean square <span class="math notranslate nohighlight">\(\sqrt{\frac{1}{n}\sum_i{x_i^2}}\)</span> of a row if the wave is 1d. It calculates column based if the wave is 2d.
The operation takes 1 to N arguments. The input data must be 1d or 2d, numeric and have at least one data point.
The operations works column based, such that for each column e.g. the average of all row values is determined. An 2d input array of size MxN is returned as 1d array of the size N.
When called with a single argument the operation accepts multiple data waves.
For this case the operation is applied on each input data wave independently and returns the same number of data waves.
The returned data type is <cite>SF_DATATYPE_RMS</cite>.
If input data type is <cite>SF_DATATYPE_SWEEP</cite> from the data operation the sweep meta data is transferred to the returned data waves.
The default suggested x-axis values for the formula plotter are sweep numbers.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>rms<span class="o">(</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">2</span>.160246899469287<span class="o">]</span>

rms<span class="o">([</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span><span class="o">]</span>,<span class="o">[</span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span>,<span class="w"> </span><span class="m">4</span><span class="o">]</span>,<span class="o">[</span><span class="m">3</span>,<span class="w"> </span><span class="m">4</span>,<span class="w"> </span><span class="m">5</span><span class="o">])</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">2</span>.160246899469287,<span class="w"> </span><span class="m">3</span>.109126351029605,<span class="w"> </span><span class="m">4</span>.08248290463863<span class="o">]</span>
</pre></div>
</div>
</section>
<section id="variance">
<h3>variance<a class="headerlink" href="#variance" title="Link to this heading">¶</a></h3>
<p><cite>variance</cite> calculates the variance of a row if the wave is 1d. It calculates column based if the wave is 2d.
Note that compared to the Igor Pro function <cite>variance()</cite> the operation does <em>not</em> ignore NaN or Inf.
The operation takes 1 to N arguments. The input data must be 1d or 2d, numeric and have at least one data point.
The operations works column based, such that for each column e.g. the average of all row values is determined. An 2d input array of size MxN is returned as 1d array of the size N.
When called with a single argument the operation accepts multiple data waves.
For this case the operation is applied on each input data wave independently and returns the same number of data waves.
The returned data type is <cite>SF_DATATYPE_VARIANCE</cite>.
If input data type is <cite>SF_DATATYPE_SWEEP</cite> from the data operation the sweep meta data is transferred to the returned data waves.
The default suggested x-axis values for the formula plotter are sweep numbers.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>variance<span class="o">(</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">4</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">2</span>.33333<span class="o">]</span>

variance<span class="o">([</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">4</span><span class="o">]</span>,<span class="o">[</span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span>,<span class="w"> </span><span class="m">2</span><span class="o">]</span>,<span class="o">[</span><span class="m">4</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">1</span><span class="o">])</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">2</span>.33333,<span class="w"> </span><span class="m">0</span>.33333,<span class="w"> </span><span class="m">2</span>.33333<span class="o">]</span>
</pre></div>
</div>
</section>
<section id="stdev">
<h3>stdev<a class="headerlink" href="#stdev" title="Link to this heading">¶</a></h3>
<p><cite>stdev</cite> calculates the variance of a row if the wave is 1d. It calculates column based if the wave is 2d.
The operation does <em>not</em> ignore NaN or Inf.
The operation takes 1 to N arguments. The input data must be 1d or 2d, numeric and have at least one data point.
The operations works column based, such that for each column e.g. the average of all row values is determined. An 2d input array of size MxN is returned as 1d array of the size N.
When called with a single argument the operation accepts multiple data waves.
For this case the operation is applied on each input data wave independently and returns the same number of data waves.
The returned data type is <cite>SF_DATATYPE_STDEV</cite>.
If input data type is <cite>SF_DATATYPE_SWEEP</cite> from the data operation the sweep meta data is transferred to the returned data waves.
The default suggested x-axis values for the formula plotter are sweep numbers.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>stdev<span class="o">(</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">4</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">1</span>.52753<span class="o">]</span>

stdev<span class="o">([</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">4</span><span class="o">]</span>,<span class="o">[</span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span>,<span class="w"> </span><span class="m">2</span><span class="o">]</span>,<span class="o">[</span><span class="m">4</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">1</span><span class="o">])</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">1</span>.52753,<span class="w"> </span><span class="m">0</span>.57735,<span class="w"> </span><span class="m">1</span>.52753<span class="o">]</span>
</pre></div>
</div>
</section>
</section>
<section id="igor-pro-wrappers">
<h2>Igor Pro Wrappers<a class="headerlink" href="#igor-pro-wrappers" title="Link to this heading">¶</a></h2>
<section id="area">
<h3>area<a class="headerlink" href="#area" title="Link to this heading">¶</a></h3>
<p>Use <cite>area</cite> to calculate the area below a 1D array using trapezoidal integration.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>area<span class="o">(</span>array<span class="w"> </span>data<span class="o">[</span>,<span class="w"> </span>variable<span class="w"> </span>zero<span class="o">])</span>
</pre></div>
</div>
<p>The first argument is the data, the second argument specifies if the data is zeroed. Zeroing refers to an additional differentiation and integration of the data prior the
area calculation. If the <cite>zero</cite> argument is set to 0 then zeroing is disabled. By default zeroing is enabled.
If zeroing is enabled the input data must have at least 3 points. If zeroing is disabled the input data must have at least one point.
The operation ignores NaN in the data.
The operations works column based, such that for each column e.g. the area of all row values is determined. An 2d input array of size MxN is returned as 1d array of the size N.
An 3d input array of size MxNxO is returned as 2d array of the size NxO.
The operation accepts multiple data waves for the data argument.
For this case the operation is applied on each input data wave independently and returns the same number of data waves.
The returned data type is <cite>SF_DATATYPE_AREA</cite>.
If input data type is <cite>SF_DATATYPE_SWEEP</cite> from the data operation the sweep meta data is transferred to the returned data waves.
The default suggested x-axis values for the formula plotter are sweep numbers.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>area<span class="o">([</span><span class="m">0</span>,<span class="w"> </span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span>,<span class="w"> </span><span class="m">4</span><span class="o">]</span>,<span class="w"> </span><span class="m">0</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">8</span><span class="o">]</span>

area<span class="o">([</span><span class="m">0</span>,<span class="w"> </span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span>,<span class="w"> </span><span class="m">4</span><span class="o">]</span>,<span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">4</span><span class="o">]</span>
</pre></div>
</div>
</section>
<section id="derivative">
<h3>derivative<a class="headerlink" href="#derivative" title="Link to this heading">¶</a></h3>
<p>Use <cite>derivative</cite> to differentiate along rows for 1- and 2-dimensional data.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>derivative<span class="o">(</span>array<span class="w"> </span>data<span class="o">)</span>
</pre></div>
</div>
<p>Central differences are used. The same amount of points as the input is returned.
The input data must have at least one point.
The operation ignores NaN in the data.
The operation accepts multiple data waves for the data argument.
For this case the operation is applied on each input data wave independently and returns the same number of data waves.
The returned data type is <cite>SF_DATATYPE_DERIVATIVE</cite>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>derivative<span class="o">(</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">4</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">1</span>,<span class="w"> </span><span class="m">1</span>.5,<span class="w"> </span><span class="m">2</span><span class="o">]</span>

derivative<span class="o">([</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">4</span><span class="o">]</span>,<span class="o">[</span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span>,<span class="w"> </span><span class="m">2</span><span class="o">]</span>,<span class="o">[</span><span class="m">4</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">1</span><span class="o">])</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">1</span>,<span class="w"> </span><span class="m">1</span>,<span class="w"> </span>-2<span class="o">]</span>,<span class="o">[</span><span class="m">1</span>.5,<span class="w"> </span><span class="m">0</span>,<span class="w"> </span>-1.5<span class="o">]</span>,<span class="o">[</span><span class="m">2</span>,<span class="w"> </span>-1,<span class="w"> </span>-1<span class="o">]</span>
</pre></div>
</div>
</section>
<section id="integrate">
<h3>integrate<a class="headerlink" href="#integrate" title="Link to this heading">¶</a></h3>
<p>Use <cite>integrate</cite> to apply trapezoidal integration along rows. The operation returns the same number of points as the input wave(s).</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>integrate<span class="o">(</span>array<span class="w"> </span>data<span class="o">)</span>
</pre></div>
</div>
<p>Note that due to the end point problem it is not the counter-part of <cite>derivative</cite>.
The input data must have at least one point.
The operation ignores NaN in the data.
The operation accepts multiple data waves for the data argument.
For this case the operation is applied on each input data wave independently and returns the same number of data waves.
The returned data type is <cite>SF_DATATYPE_INTEGRATE</cite>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>integrate<span class="o">(</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">4</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">0</span>,<span class="w"> </span><span class="m">1</span>.5,<span class="w"> </span><span class="m">4</span>.5<span class="o">]</span>

integrate<span class="o">([</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">4</span><span class="o">]</span>,<span class="o">[</span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span>,<span class="w"> </span><span class="m">2</span><span class="o">]</span>,<span class="o">[</span><span class="m">4</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">1</span><span class="o">])</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">0</span>,<span class="w"> </span><span class="m">0</span>,<span class="w"> </span><span class="m">0</span><span class="o">]</span>,<span class="o">[</span><span class="m">1</span>.5,<span class="w"> </span><span class="m">2</span>.5,<span class="w"> </span><span class="m">3</span><span class="o">]</span>,<span class="o">[</span><span class="m">4</span>.5,<span class="w"> </span><span class="m">5</span>,<span class="w"> </span><span class="m">4</span>.5<span class="o">]</span>
</pre></div>
</div>
</section>
<section id="butterworth">
<h3>butterworth<a class="headerlink" href="#butterworth" title="Link to this heading">¶</a></h3>
<p>The operation <cite>butterworth</cite> applies a butterworth filter on the given data
using <cite>FilterIIR</cite> from Igor Pro. The operation calculates along rows. It takes
four arguments:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>butterworth<span class="o">(</span>array<span class="w"> </span>data,<span class="w"> </span>variable<span class="w"> </span>lowPassCutoffInHz,<span class="w"> </span>variable<span class="w"> </span>highPassCutoffInHz,<span class="w"> </span>variable<span class="w"> </span>order<span class="o">)</span>
</pre></div>
</div>
<p>The first parameter <cite>data</cite> is intended to be used with the <cite>data()</cite> operation but
can be an arbitrary numeric array. The parameters lowPassCutoffInHz and
highPassCutoffInHz must be given in Hz. The maximum value for <cite>order</cite> is 100.
The operation accepts multiple data waves for the data argument.
For this case the operation is applied on each input data wave independently and returns the same number of data waves.
The returned data type is <cite>SF_DATATYPE_BUTTERWORTH</cite>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>butterworth<span class="o">([</span><span class="m">0</span>,1,0,1,0,1,0,1<span class="o">]</span>,<span class="w"> </span>90E3,<span class="w"> </span>100E3,<span class="w"> </span><span class="m">2</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">0</span>,<span class="w"> </span><span class="m">0</span>.863871,<span class="w"> </span><span class="m">0</span>.235196,<span class="w"> </span><span class="m">0</span>.692709,<span class="w"> </span><span class="m">0</span>.359758,<span class="w"> </span><span class="m">0</span>.60206,<span class="w"> </span><span class="m">0</span>.425727,<span class="w"> </span><span class="m">0</span>.554052<span class="o">]</span>
</pre></div>
</div>
</section>
<section id="xvalues-and-time">
<h3>xvalues and time<a class="headerlink" href="#xvalues-and-time" title="Link to this heading">¶</a></h3>
<p>The function <cite>xvalues</cite> or <cite>time</cite> are synonyms for the same function.
The function returns a wave containing the x-scaling of the
input data.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>xvalues<span class="o">(</span>array<span class="w"> </span>data<span class="o">)</span>
</pre></div>
</div>
<p>The output data wave has the same dimension as the input data. The x-scaling values are filled in the rows for all dimensions.
The operation accepts multiple data waves for the data argument.
For this case the operation is applied on each input data wave independently and returns the same number of data waves.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>xvalues<span class="o">(</span><span class="m">10</span>,<span class="w"> </span><span class="m">20</span>,<span class="w"> </span><span class="m">30</span>,<span class="w"> </span><span class="m">40</span>,<span class="w"> </span><span class="m">50</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">0</span>,<span class="w"> </span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span>,<span class="w"> </span><span class="m">4</span><span class="o">]</span>

//<span class="w"> </span>The<span class="w"> </span>sweeps<span class="w"> </span><span class="k">in</span><span class="w"> </span>this<span class="w"> </span>example<span class="w"> </span>were<span class="w"> </span>sampled<span class="w"> </span>at<span class="w"> </span><span class="m">250</span><span class="w"> </span>kHz.
//<span class="w"> </span>For<span class="w"> </span>each<span class="w"> </span>data<span class="w"> </span>point<span class="w"> </span><span class="k">in</span><span class="w"> </span>the<span class="w"> </span>sweep<span class="w"> </span>the<span class="w"> </span><span class="nb">time</span><span class="w"> </span>is<span class="w"> </span>returned.
time<span class="o">(</span>data<span class="o">(</span><span class="k">select</span><span class="o">(</span>selrange<span class="o">([</span><span class="m">0</span>,<span class="w"> </span><span class="m">1000</span><span class="o">])</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD<span class="o">)</span>,<span class="w"> </span>selsweeps<span class="o">())))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">0</span>,<span class="w"> </span><span class="m">0</span>.004,<span class="w"> </span><span class="m">0</span>.008,<span class="w"> </span><span class="m">0</span>.012,<span class="w"> </span>...<span class="o">]</span>
</pre></div>
</div>
</section>
<section id="setscale">
<h3>setscale<a class="headerlink" href="#setscale" title="Link to this heading">¶</a></h3>
<p><cite>setscale</cite> sets a new wave scaling to an input wave. It accepts 2 to 5 arguments.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>setscale<span class="o">(</span>array<span class="w"> </span>data,<span class="w"> </span>string<span class="w"> </span>dim<span class="o">[</span>,<span class="w"> </span>variable<span class="w"> </span>dimOffset<span class="o">[</span>,<span class="w"> </span>variable<span class="w"> </span>dimDelta<span class="o">[</span>,<span class="w"> </span>string<span class="w"> </span>unit<span class="o">]]])</span>
</pre></div>
</div>
<dl class="simple">
<dt>data</dt><dd><p>input data wave</p>
</dd>
<dt>dim</dt><dd><p>dimension where the scale should be set, either <cite>d</cite>, <cite>x</cite>, <cite>y</cite>, <cite>z</cite> or <cite>t</cite>.</p>
</dd>
<dt>dimOffset</dt><dd><p>optional, the scale offset for the first data point. If not specified, <cite>0</cite> is used as default.</p>
</dd>
<dt>dimDelta</dt><dd><p>optional, the scale delta for the data point distance. If not specified, <cite>1</cite> is used as default.</p>
</dd>
<dt>unit</dt><dd><p>optional, the scale unit for the data points. If not specified, <cite>“”</cite> is used as default.</p>
</dd>
</dl>
<p>If <cite>d</cite> is used for dim, then in analogy to Igor Pros SetScale operation the dimOffset and dimDelta argument set the nominal minimum and nominal maximum data values of the wave.</p>
<p>If <cite>x</cite>, <cite>y</cite>, <cite>z</cite> or <cite>t</cite> is used for dim and dimDelta is <cite>0</cite> then the default dimDelta <cite>1</cite> is used.</p>
<p>The operation accepts multiple data waves for the data argument.
For this case the operation is applied on each input data wave independently and returns the same number of data waves.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>xvalues<span class="o">(</span>setscale<span class="o">([</span><span class="m">0</span>,<span class="w"> </span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span>,<span class="w"> </span><span class="m">4</span><span class="o">]</span>,<span class="w"> </span>x,<span class="w"> </span><span class="m">0</span>,<span class="w"> </span><span class="m">0</span>.2,<span class="w"> </span>firkin<span class="o">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">0</span>,<span class="w"> </span><span class="m">0</span>.2,<span class="w"> </span><span class="m">0</span>.4,<span class="w"> </span><span class="m">0</span>.6,<span class="w"> </span><span class="m">0</span>.8<span class="o">]</span>
</pre></div>
</div>
</section>
<section id="selchannels">
<h3>selchannels<a class="headerlink" href="#selchannels" title="Link to this heading">¶</a></h3>
<p>The operation <cite>selchannels</cite> allows to select channels.
<cite>selchannels([str name]+)</cite> converts named channels from strings to numbers.</p>
<p>The function accepts an arbitrary amount of channel names like <cite>AD</cite>, <cite>DA</cite> or
<cite>TTL</cite> with a combination of numbers <cite>AD1</cite> or channel numbers alone like <cite>2</cite>.
The maximum allowed channel number is <cite>NUM_MAX_CHANNELS</cite> (16). For all channel
types the channel numbers as given on the DAEphys panel are accepted.
The operation returns a numeric array of <cite>[[channelType+], [channelNumber+]]</cite> that has as
row dimension the number of the input strings.
When called without argument all channel types / channel numbers are set by setting the
returned value for type and number to <cite>NaN</cite>.
The result of <cite>selchannels</cite> has a data type attributed.</p>
<p><cite>selchannels</cite> is intended to be used with the <cite>select()</cite> operation.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>selchannels<span class="o">([</span>AD0,<span class="w"> </span>AD1,<span class="w"> </span>DA0,<span class="w"> </span>DA1<span class="o">])</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[[</span><span class="m">0</span>,<span class="w"> </span><span class="m">0</span>,<span class="w"> </span><span class="m">1</span>,<span class="w"> </span><span class="m">1</span><span class="o">]</span>,<span class="w"> </span><span class="o">[</span><span class="m">0</span>,<span class="w"> </span><span class="m">1</span>,<span class="w"> </span><span class="m">0</span>,<span class="w"> </span><span class="m">1</span><span class="o">]]</span>

//<span class="w"> </span>Internally<span class="w"> </span>NaN<span class="w"> </span>is<span class="w"> </span>evaluated<span class="w"> </span>as<span class="w"> </span>joker<span class="w"> </span><span class="k">for</span><span class="w"> </span>all<span class="w"> </span>channel<span class="w"> </span>types<span class="w"> </span>and<span class="w"> </span>all<span class="w"> </span>channel<span class="w"> </span>numbers
selchannels<span class="o">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[[</span>NaN<span class="o">]</span>,<span class="w"> </span><span class="o">[</span>NaN<span class="o">]]</span>
</pre></div>
</div>
</section>
<section id="selsweeps">
<h3>selsweeps<a class="headerlink" href="#selsweeps" title="Link to this heading">¶</a></h3>
<p>The operation <cite>selsweeps</cite> allows to select sweeps by their number and returns an 1d-array with the sweep numbers.
The operation accepts numbers, arrays and ranges as arguments. Any number of arguments can be specified.
In case no argument is given, then all sweeps are returned or if there are no sweeps a null wave is returned.
Each unique sweep number is returned only once.
The result of <cite>selsweeps</cite> has a data type attributed.</p>
<p><cite>selsweeps</cite> is intended to be used with the <cite>select()</cite> operation.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># For this example two sweeps were acquired</span>
selsweeps<span class="o">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">0</span>,<span class="w"> </span><span class="m">1</span><span class="o">]</span>

selsweeps<span class="o">(</span><span class="m">0</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span>

selsweeps<span class="o">([</span><span class="m">1</span>,<span class="w"> </span><span class="m">0</span><span class="o">])</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">1</span>,<span class="w"> </span><span class="m">0</span><span class="o">]</span>

selsweeps<span class="o">(</span><span class="m">0</span>...2<span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">0</span>,<span class="w"> </span><span class="m">1</span><span class="o">]</span>

<span class="c1"># For this example 30 sweeps were acquired</span>
selsweeps<span class="o">(</span><span class="m">10</span>,<span class="w"> </span><span class="o">[</span><span class="m">20</span>,<span class="w"> </span><span class="m">24</span><span class="o">]</span>,<span class="w"> </span><span class="m">26</span>...30<span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">10</span>,<span class="w"> </span><span class="m">20</span>,<span class="w"> </span><span class="m">24</span>,<span class="w"> </span><span class="m">26</span>,<span class="w"> </span><span class="m">27</span>,<span class="w"> </span><span class="m">28</span>,<span class="w"> </span><span class="m">29</span><span class="o">]</span>

<span class="c1"># Each unique sweep number is returned only once</span>
selsweeps<span class="o">(</span><span class="m">0</span>,<span class="w"> </span><span class="m">0</span>,<span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">0</span>,<span class="w"> </span><span class="m">1</span><span class="o">]</span>
</pre></div>
</div>
</section>
<section id="selrange">
<h3>selrange<a class="headerlink" href="#selrange" title="Link to this heading">¶</a></h3>
<p>The operation <cite>selrange</cite> allows to specify a time interval either by epoch name or numbers in ms.
It takes zero or one argument, an epoch name/wildcard or an array with two
numeric values. The numeric values specify the start and end of a range.
The operation returns a dataset with a range specification array.
In case no argument is given, then a dataset with a full-range specification is returned.
The result of <cite>selrange</cite> has a data type attributed.</p>
<p><cite>selrange</cite> is intended to be used with the <cite>select()</cite> operation.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># returns a full-range</span>
selrange<span class="o">()</span>

<span class="c1"># refers to epoch E1</span>
selrange<span class="o">(</span>E1<span class="o">)</span>

<span class="c1"># all stimset epochs</span>
selrange<span class="o">(</span><span class="s2">&quot;E*&quot;</span><span class="o">)</span>

<span class="c1"># refers to 30 ms to 100 ms</span>
selrange<span class="o">([</span><span class="m">30</span>,<span class="w"> </span><span class="m">100</span><span class="o">])</span>

<span class="c1"># refers to the range set by cursor A and B</span>
selrange<span class="o">(</span>cursors<span class="o">(</span>A,B<span class="o">))</span>
</pre></div>
</div>
</section>
<section id="selvis">
<h3>selvis<a class="headerlink" href="#selvis" title="Link to this heading">¶</a></h3>
<p>The operation <cite>selvis</cite> allows to specify if selected data is taken from all sweeps or from the displayed sweeps only.
It takes zero or one argument that can be either <cite>all</cite> or <cite>displayed</cite>.
In case no argument is given, then the operation defaults to <cite>displayed</cite>.
The operation returns a text wave with a single element.
The result of <cite>selvis</cite> has a data type attributed.</p>
<p><cite>selvis</cite> is intended to be used with the <cite>select()</cite> operation.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># refers to displayed</span>
selvis<span class="o">()</span>

<span class="c1"># refers to all</span>
selvis<span class="o">(</span>all<span class="o">)</span>

<span class="c1"># refers displayed</span>
selvis<span class="o">(</span>displayed<span class="o">)</span>
</pre></div>
</div>
</section>
<section id="selcm">
<h3>selcm<a class="headerlink" href="#selcm" title="Link to this heading">¶</a></h3>
<p>The operation <cite>selcm</cite> allows to specify how select filters data for clamp mode.
It takes between zero and any number of arguments.
Allowed arguments are <cite>none</cite>, <cite>ic</cite>, <cite>vc</cite>, <cite>izero</cite>, <cite>all</cite>. If no argument is given then <cite>selcm</cite> defaults to <cite>all</cite>.
The operation returns a a numeric value with a clamp code that is a logical ORed result of the given clamp modes.
The result of <cite>selcm</cite> has a data type attributed.</p>
<p><cite>selcm</cite> is intended to be used with the <cite>select()</cite> operation.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># sweep data in any clamp mode</span>
selcm<span class="o">()</span>

<span class="c1"># sweep data acquired in current clamp and voltage clamp mode</span>
selcm<span class="o">(</span>ic,<span class="w"> </span>vc<span class="o">)</span>

<span class="c1"># sweep data acquired with no clamp mode (unassociated channels)</span>
selcm<span class="o">(</span>none<span class="o">)</span>
</pre></div>
</div>
</section>
<section id="selstimset">
<h3>selstimset<a class="headerlink" href="#selstimset" title="Link to this heading">¶</a></h3>
<p>The operation <cite>selstimset</cite> allows to specify how select filters data regarding the stimset wave name.
It takes between zero and any number of arguments.
Allowed arguments are strings that can contain wildcards.
If no argument is given then <cite>selstimset</cite> defaults to <cite>*</cite>.
The operation returns a a text wave with the stimset wave name wildcard patterns.
The result of <cite>selstimset</cite> has a data type attributed.</p>
<p><cite>selstimset</cite> is intended to be used with the <cite>select()</cite> operation.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># sweep data with any stimset wave name</span>
selstimset<span class="o">()</span>

<span class="c1"># sweep data with all stimset wave names that start with pinky and all that end with brain</span>
selstimset<span class="o">(</span><span class="s2">&quot;pinky*&quot;</span>,<span class="w"> </span><span class="s2">&quot;*brain&quot;</span><span class="o">)</span>
</pre></div>
</div>
</section>
<section id="selexp">
<h3>selexp<a class="headerlink" href="#selexp" title="Link to this heading">¶</a></h3>
<p>The operation <cite>selexp</cite> allows to specify how select filters data regarding the experiment name.
It takes exactly one string argument. The string that can contain wildcards.
The operation returns a a text wave with the experiment name wildcard pattern.
The result of <cite>selexp</cite> has a data type attributed.</p>
<p><cite>selexp</cite> is intended to be used with the <cite>select()</cite> operation.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># sweep data from a specific experiment</span>
selexp<span class="o">(</span><span class="s2">&quot;MyFirstExperiment.pxp&quot;</span><span class="o">)</span>

<span class="c1"># sweep data from a specific experiment</span>
selexp<span class="o">(</span><span class="s2">&quot;MySecondExp*&quot;</span><span class="o">)</span>
</pre></div>
</div>
</section>
<section id="seldev">
<h3>seldev<a class="headerlink" href="#seldev" title="Link to this heading">¶</a></h3>
<p>The operation <cite>seldev</cite> allows to specify how select filters data regarding the DAC device name.
It takes exactly one string argument. The string that can contain wildcards.
The operation returns a a text wave with the device name wildcard pattern.
The result of <cite>seldev</cite> has a data type attributed.</p>
<p><cite>seldev</cite> is intended to be used with the <cite>select()</cite> operation.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># sweep data from a specific device</span>
seldev<span class="o">(</span><span class="s2">&quot;ITC18*&quot;</span><span class="o">)</span>

<span class="c1"># sweep data from a specific device</span>
seldev<span class="o">(</span><span class="s2">&quot;Dev*&quot;</span><span class="o">)</span>
</pre></div>
</div>
</section>
<section id="selsetcyclecount">
<h3>selsetcyclecount<a class="headerlink" href="#selsetcyclecount" title="Link to this heading">¶</a></h3>
<p>When the operation <cite>selsetcyclecount</cite> is used with select it includes all sweeps with the specified set cycle count.
The operation takes exactly one numerical argument.
The operation returns a a numeric wave with a single element that has the value of the given argument.
The result of <cite>selsetcyclecount</cite> has a data type attributed.</p>
<p><cite>selsetcyclecount</cite> is intended to be used with the <cite>select()</cite> operation.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># sweeps that have a set cycle count of 5</span>
selsetcyclecount<span class="o">(</span><span class="m">5</span><span class="o">)</span>
</pre></div>
</div>
</section>
<section id="selsetsweepcount">
<h3>selsetsweepcount<a class="headerlink" href="#selsetsweepcount" title="Link to this heading">¶</a></h3>
<p>When the operation <cite>selsetsweepcount</cite> is used with select it includes all selection with the specified set sweep count.
The operation takes exactly one numerical argument.
The operation returns a a numeric wave with a single element that has the value of the given argument.
The result of <cite>selsetsweepcount</cite> has a data type attributed.</p>
<p><cite>selsetsweepcount</cite> is intended to be used with the <cite>select()</cite> operation.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># sweeps that have a set sweep count of 2</span>
selsetsweepcount<span class="o">(</span><span class="m">2</span><span class="o">)</span>
</pre></div>
</div>
</section>
<section id="selsciindex">
<h3>selsciindex<a class="headerlink" href="#selsciindex" title="Link to this heading">¶</a></h3>
<p>When the operation <cite>selsciindex</cite> is used with select it includes all selections that have the n-th unique stimset cycle id.
The specific order of the stimset cycle ids before this operation is applied depends on the other select filters applied in the <cite>select</cite> operation.
Selections with no stimset cycle id are discarded and not indexed.
The stimset cycle id depends on the headstage and thus, on channel type and channel number of the specific sweep.
The selection results are determined per headstage. Thus, if the other select filters result
in selections include multiple headstages then the n-th unique stimset cycle id is selected for each headstage seperately.
Selections are sorted by the following priority list (higher to lower): experiment name, sweep number, channel type, channel number.
The operation takes exactly one numerical argument.
The operation returns a a numeric wave with a single element that has the value of the given argument.
The result of <cite>selsciindex</cite> has a data type attributed.</p>
<p><cite>selsciindex</cite> is intended to be used with the <cite>select()</cite> operation.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Looks at all sweep starting from sweep 3 with channel AD0. Selects all sweeps that have starting from sweep 3 the third unique stimset cycle id.</span>
<span class="k">select</span><span class="o">(</span>selsweeps<span class="o">([</span><span class="m">3</span>,<span class="w"> </span><span class="m">1000</span><span class="o">])</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD0<span class="o">)</span>,<span class="w"> </span>selsciindex<span class="o">(</span><span class="m">3</span><span class="o">))</span>

<span class="c1"># example, where the first three columns are the result of a selection, the last two columns are added for illustration</span>
<span class="c1"># a possible selection with a two headstage setup could be select(selvis(all), selsweeps([0, 3]), selchannels(AD))</span>
Sweep<span class="w"> </span>ChannelType<span class="w"> </span>ChannelNumer<span class="w"> </span>Headstage<span class="w"> </span>StimsetCycleId
<span class="m">0</span><span class="w">     </span>AD<span class="w">          </span><span class="m">6</span><span class="w">            </span><span class="m">0</span><span class="w">         </span><span class="m">43</span>
<span class="m">0</span><span class="w">     </span>AD<span class="w">          </span><span class="m">7</span><span class="w">            </span><span class="m">1</span><span class="w">         </span><span class="m">45</span>
<span class="m">1</span><span class="w">     </span>AD<span class="w">          </span><span class="m">6</span><span class="w">            </span><span class="m">0</span><span class="w">         </span><span class="m">43</span>
<span class="m">1</span><span class="w">     </span>AD<span class="w">          </span><span class="m">7</span><span class="w">            </span><span class="m">1</span><span class="w">         </span><span class="m">46</span>
<span class="m">2</span><span class="w">     </span>AD<span class="w">          </span><span class="m">6</span><span class="w">            </span><span class="m">0</span><span class="w">         </span><span class="m">44</span>
<span class="m">2</span><span class="w">     </span>AD<span class="w">          </span><span class="m">7</span><span class="w">            </span><span class="m">1</span><span class="w">         </span><span class="m">46</span>

<span class="c1"># if based on this selection selsciindex(0) is applied:</span>
<span class="c1"># select(selvis(all), selsweeps([0, 3]), selchannels(AD), selsciindex(0))</span>
<span class="c1"># The result is</span>
Sweep<span class="w"> </span>ChannelType<span class="w"> </span>ChannelNumer<span class="w"> </span>Headstage<span class="w"> </span>StimsetCycleId
<span class="m">0</span><span class="w">     </span>AD<span class="w">          </span><span class="m">6</span><span class="w">            </span><span class="m">0</span><span class="w">         </span><span class="m">43</span>
<span class="m">1</span><span class="w">     </span>AD<span class="w">          </span><span class="m">6</span><span class="w">            </span><span class="m">0</span><span class="w">         </span><span class="m">43</span>
<span class="m">0</span><span class="w">     </span>AD<span class="w">          </span><span class="m">7</span><span class="w">            </span><span class="m">1</span><span class="w">         </span><span class="m">45</span>
<span class="c1"># for headstage 0 the 0-th SCI index is 43</span>
<span class="c1"># for headstage 1 the 0-th SCI index is 45</span>

<span class="c1"># if based on this selection selsciindex(1) is applied:</span>
<span class="c1"># select(selvis(all), selsweeps([0, 3]), selchannels(AD), selsciindex(1))</span>
<span class="c1"># The result is</span>
Sweep<span class="w"> </span>ChannelType<span class="w"> </span>ChannelNumer<span class="w"> </span>Headstage<span class="w"> </span>StimsetCycleId
<span class="m">2</span><span class="w">     </span>AD<span class="w">          </span><span class="m">6</span><span class="w">            </span><span class="m">0</span><span class="w">         </span><span class="m">44</span>
<span class="m">1</span><span class="w">     </span>AD<span class="w">          </span><span class="m">7</span><span class="w">            </span><span class="m">1</span><span class="w">         </span><span class="m">46</span>
<span class="m">2</span><span class="w">     </span>AD<span class="w">          </span><span class="m">7</span><span class="w">            </span><span class="m">1</span><span class="w">         </span><span class="m">46</span>
<span class="c1"># for headstage 0 the 1-th SCI index is 44</span>
<span class="c1"># for headstage 1 the 1-th SCI index is 46</span>
</pre></div>
</div>
</section>
<section id="selracindex">
<h3>selracindex<a class="headerlink" href="#selracindex" title="Link to this heading">¶</a></h3>
<p>When the operation <cite>selracindex</cite> is used with select it includes all selections that have the n-th unique repeated acquisition cycle id.
The specific order of the repeated acquisition cycle ids before this operation is applied depends on the other select filters applied in the <cite>select</cite> operation.
Selections with no repeated acquisition cycle ids are discarded and not indexed.
The selections prior to the application of <cite>selracindex</cite> are sorted by the following priority list (higher to lower): experiment name, sweep number, channel type, channel number.
The operation takes exactly one numerical argument.
The operation returns a a numeric wave with a single element that has the value of the given argument.
The result of <cite>selracindex</cite> has a data type attributed.</p>
<p><cite>selracindex</cite> is intended to be used with the <cite>select()</cite> operation.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Looks at all sweep starting from sweep 3 with channel AD0. Selects all sweeps that have starting from sweep 3 the third unique repeated acquisition cycle id.</span>
<span class="k">select</span><span class="o">(</span>selsweeps<span class="o">([</span><span class="m">3</span>,<span class="w"> </span><span class="m">1000</span><span class="o">])</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD0<span class="o">)</span>,<span class="w"> </span>selracindex<span class="o">(</span><span class="m">3</span><span class="o">))</span>
</pre></div>
</div>
</section>
<section id="selexpandsci">
<h3>selexpandsci<a class="headerlink" href="#selexpandsci" title="Link to this heading">¶</a></h3>
<p>When the operation <cite>selexpandsci</cite> is used with select then select operates in a two-step regime.
First the common select filters e.g. by sweep number, stimset, etc. are applied.
Then for each of these selections the selections with the same stimset cycle id are also added.
For example when a single sweep/channel is selected all other sweeps from the same stimset cycle id can be collected for the resulting selections.
Intersections with additional selections from another select are applied afterwards.
The operation takes no argument.
The result of <cite>selexpandsci</cite> has a data type attributed.</p>
<p><cite>selexpandsci</cite> is intended to be used with the <cite>select()</cite> operation.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Looks at all AD channels from sweep 1 and selects all sweeps with the same stimset cycle id.</span>
<span class="k">select</span><span class="o">(</span>selsweeps<span class="o">(</span><span class="m">1</span><span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD<span class="o">)</span>,<span class="w"> </span>selexpandsci<span class="o">())</span>
</pre></div>
</div>
</section>
<section id="selexpandrac">
<h3>selexpandrac<a class="headerlink" href="#selexpandrac" title="Link to this heading">¶</a></h3>
<p>When the operation <cite>selexpandrac</cite> is used with select then select operates in a two-step regime.
First the common select filters e.g. by sweep number, stimset, etc. are applied.
Then for each of these selections the selections with the same repeated acquisition cycle are also added.
So for example when a single sweep/channel is selected all other sweeps from the same repeated acquisition cycle can be collected for the resulting selections.
Intersections with additional selections from another select are applied afterwards.
The operation takes no argument.
The result of <cite>selexpandrac</cite> has a data type attributed.</p>
<p><cite>selexpandrac</cite> is intended to be used with the <cite>select()</cite> operation.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Looks at all AD channels from sweep 1 and selects all sweeps from the same repeated acquisition cycle.</span>
<span class="k">select</span><span class="o">(</span>selsweeps<span class="o">(</span><span class="m">1</span><span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD<span class="o">)</span>,<span class="w"> </span>selexpandrac<span class="o">())</span>
</pre></div>
</div>
</section>
<section id="selivsccsweepqc">
<h3>selivsccsweepqc<a class="headerlink" href="#selivsccsweepqc" title="Link to this heading">¶</a></h3>
<p>The operation <cite>selivsccsweepqc</cite> allows to specify how select filters data
regarding the sweep quality check from the IVSCC analysis functions.
It takes between one argument that can be either <cite>failed</cite> or <cite>passed</cite>.
The operation returns a a text wave with the argument value as string.
The result of <cite>selivsccsweepqc</cite> has a data type attributed.</p>
<p><cite>selivsccsweepqc</cite> is intended to be used with the <cite>select()</cite> operation.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># sweep data where the analysis function passed the sweepqc check</span>
selivsccsweepqc<span class="o">(</span>passed<span class="o">)</span>

<span class="c1"># sweep data where the analysis function failed the sweepqc check</span>
selivsccsweepqc<span class="o">(</span>failed<span class="o">)</span>
</pre></div>
</div>
</section>
<section id="selivsccsetqc">
<h3>selivsccsetqc<a class="headerlink" href="#selivsccsetqc" title="Link to this heading">¶</a></h3>
<p>The operation <cite>selivsccsetqc</cite> allows to specify how select filters data
regarding the set quality check from the IVSCC analysis functions.
It takes between one argument that can be either <cite>failed</cite> or <cite>passed</cite>.
The operation returns a a text wave with the argument value as string.
The result of <cite>selivsccsetqc</cite> has a data type attributed.</p>
<p><cite>selivsccsetqc</cite> is intended to be used with the <cite>select()</cite> operation.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># sweep data where the analysis function passed the setqc check</span>
selivsccsetqc<span class="o">(</span>passed<span class="o">)</span>

<span class="c1"># sweep data where the analysis function failed the setqc check</span>
selivsccsetqc<span class="o">(</span>failed<span class="o">)</span>
</pre></div>
</div>
</section>
<section id="cursors">
<h3>cursors<a class="headerlink" href="#cursors" title="Link to this heading">¶</a></h3>
<p>The <cite>cursors</cite> operation returns the x-values of the named cursor(s).</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cursors<span class="o">([</span>A-J<span class="o">]</span>+<span class="o">)</span>
</pre></div>
</div>
<p>The cursors operation takes any number of arguments. If no argument is given
it defaults to <cite>cursors(A, B)</cite>. When <cite>cursors</cite> is used as argument for a range specification, e.g. for <cite>data</cite>
two arguments for <cite>cursors</cite> should be used to have a compatible output.
Valid cursor names are A-J. The operation returns a numeric 1d-wave containing the x-values of the named cursor(s).
If a named cursor is not present, then NaN is returned as position.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cursors<span class="o">(</span>A,B<span class="o">)</span><span class="w"> </span>vs<span class="w"> </span>A,B

cursors<span class="o">()</span><span class="w"> </span>vs<span class="w"> </span>A,B<span class="w"> </span>//<span class="w"> </span>same<span class="w"> </span>as<span class="w"> </span>above

cursors<span class="o">(</span>B,A,D,J,I,G,G<span class="o">)</span><span class="w"> </span>//<span class="w"> </span>returns<span class="w"> </span>a<span class="w"> </span><span class="m">7</span><span class="w"> </span>element<span class="w"> </span>array<span class="w"> </span>with<span class="w"> </span>the<span class="w"> </span>x-values<span class="w"> </span>of<span class="w"> </span>the<span class="w"> </span>named<span class="w"> </span>cursors
</pre></div>
</div>
</section>
<section id="wave">
<h3>wave<a class="headerlink" href="#wave" title="Link to this heading">¶</a></h3>
<p>The <cite>wave</cite> operation returns the content of the referenced wave.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>wave<span class="o">(</span>string<span class="w"> </span>pathToWave<span class="o">)</span>
</pre></div>
</div>
<p>If no wave can be resolved at the given path a null wave is returned. The further handling depends how the operations receiving such null wave handles this special case.
The formula plotter skips null waves.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>wave<span class="o">(</span>root:mywave<span class="o">)</span>
</pre></div>
</div>
</section>
<section id="text">
<h3>text<a class="headerlink" href="#text" title="Link to this heading">¶</a></h3>
<p>The operation <cite>text</cite> converts the given numeric data to a text data.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>text<span class="o">(</span>array<span class="w"> </span>data<span class="o">)</span>
</pre></div>
</div>
<p>This can be used to force, for example, a category plot.
<cite>text</cite> requires numeric input data. The output data has the same dimension as the input data. The output precision for the text are 7 digits after the dot.
The operation accepts multiple data waves for the data argument.
For this case the operation is applied on each input data wave independently and returns the same number of data waves.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>range<span class="o">(</span><span class="m">5</span><span class="o">)</span><span class="w"> </span>vs<span class="w"> </span>text<span class="o">(</span>range<span class="o">(</span><span class="m">5</span><span class="o">))</span>
</pre></div>
</div>
</section>
<section id="data">
<h3>data<a class="headerlink" href="#data" title="Link to this heading">¶</a></h3>
<p>The <cite>data</cite> operation is the core of the <cite>SweepFormula</cite> library. It returns sweep data from <em>MIES</em>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>data<span class="o">(</span>selectData<span class="o">)</span>

data<span class="o">([</span>selectData,<span class="w"> </span>selectData,<span class="w"> </span>...<span class="o">])</span>
</pre></div>
</div>
<p>The operation <cite>data</cite> retrieves selected sweep data.</p>
<p>It takes one argument that is either a <cite>select</cite> operation or an array of <cite>select</cite> operations.</p>
<p>If an array of <cite>select</cite> operations is specified then over each selected data is iterated
independently. Thus, one data expression can retrieve sweep data from
multiple <cite>select</cite> operations.</p>
<p>A given <cite>selrange</cite> in <cite>select</cite> as numbers or epoch extracts a subrange of data points from the sweep. The start and end time is converted to
closest integer indices, where the included points range from <cite>startIndex</cite> to <cite>endIndex - 1</cite>. This matches the general handling
of epochs in MIES, where the data point at the end time of an epoch is not part of the epoch range.</p>
<p>For each selected sweep/channel combination data returns a data wave. The data wave contains the sweep data for the specified range/epoch.
If no sweep/channel was selected then the number of returned data waves is zero. Each data wave gets meta data about the originating sweep/channel added.
The returned data type is <cite>SF_DATATYPE_SWEEP</cite>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># AD channels of all displayed sweeps with the range 0 - 1s</span>
data<span class="o">(</span><span class="k">select</span><span class="o">(</span>selrange<span class="o">([</span><span class="m">0</span>,<span class="w"> </span><span class="m">1000</span><span class="o">])</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD<span class="o">)))</span>

<span class="c1"># epoch &quot;E1&quot; range of the AD channels of all displayed sweeps</span>
data<span class="o">(</span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span>E1<span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD<span class="o">)))</span>

<span class="c1"># epoch &quot;E1&quot; range with the start offsetted by 10ms of the AD channels of all displayed sweeps</span>
<span class="nv">sel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD<span class="o">))</span>
<span class="nv">rng</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>epochs<span class="o">(</span><span class="s2">&quot;E1&quot;</span>,<span class="w"> </span><span class="nv">$sel</span><span class="o">)</span><span class="w"> </span>+<span class="w"> </span><span class="o">[</span><span class="m">10</span>,<span class="w"> </span><span class="m">0</span><span class="o">]</span>
data<span class="o">(</span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span><span class="nv">$rng</span><span class="o">)</span>,<span class="w"> </span><span class="nv">$sel</span><span class="o">))</span>

<span class="c1"># sweep data from all epochs starting with &quot;E&quot; of the AD channels of all displayed sweeps</span>
data<span class="o">(</span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span><span class="s2">&quot;E*&quot;</span><span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD<span class="o">)))</span>

<span class="c1"># sweep data from all epochs starting with &quot;E&quot;  and &quot;TP&quot; of the AD channels of all displayed sweeps</span>
<span class="nv">sel1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD<span class="o">))</span>
<span class="nv">sel2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span><span class="s2">&quot;E*&quot;</span><span class="o">)</span>,<span class="w"> </span><span class="nv">$sel1</span><span class="o">)</span>
<span class="nv">sel3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span><span class="s2">&quot;TP*&quot;</span><span class="o">)</span>,<span class="w"> </span><span class="nv">$sel1</span><span class="o">)</span>
data<span class="o">([</span><span class="nv">$sel2</span>,<span class="w"> </span><span class="nv">$sel3</span><span class="o">])</span>

<span class="c1"># sweep data from all epochs that do not start with &quot;E&quot;  and that do start with &quot;TP&quot; of the AD channels of all displayed sweeps</span>
<span class="nv">sel1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD<span class="o">))</span>
<span class="nv">sel2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span><span class="s2">&quot;!E*&quot;</span><span class="o">)</span>,<span class="w"> </span><span class="nv">$sel1</span><span class="o">)</span>
<span class="nv">sel3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span><span class="s2">&quot;TP*&quot;</span><span class="o">)</span>,<span class="w"> </span><span class="nv">$sel1</span><span class="o">)</span>
data<span class="o">([</span><span class="nv">$sel2</span>,<span class="w"> </span><span class="nv">$sel3</span><span class="o">])</span>

<span class="c1"># extract the first pulse from TTL1 as epoch and extract the AD data in that range</span>
<span class="nv">sel1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>TTL1<span class="o">))</span>
<span class="nv">ep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>epochs<span class="o">(</span>E0_PT_P0,<span class="w"> </span><span class="nv">$sel1</span><span class="o">)</span>
data<span class="o">(</span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span><span class="nv">$ep</span><span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD<span class="o">)))</span>

<span class="c1"># extract the first pulse from TTL1 as epoch with a start and end offset, then extract the AD data in that range</span>
<span class="nv">sel1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>TTL1<span class="o">))</span>
<span class="nv">ep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>epochs<span class="o">(</span>E0_PT_P0,<span class="w"> </span><span class="nv">$sel1</span><span class="o">)</span><span class="w"> </span>+<span class="w"> </span><span class="o">[</span><span class="m">50</span>,<span class="w"> </span><span class="m">100</span><span class="o">]</span>
data<span class="o">(</span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span><span class="nv">$ep</span><span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD<span class="o">)))</span>

<span class="c1"># filter by channel, clamp mode and stimset wave name, then based on that selection create one with epoch E0 and another with epoch E1 range</span>
<span class="c1"># retrieve data for these two selections</span>
<span class="nv">sel1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD<span class="o">)</span>,<span class="w"> </span>selcm<span class="o">(</span>ic<span class="o">)</span>,<span class="w"> </span>selstimsets<span class="o">(</span><span class="s2">&quot;AD_phase0*&quot;</span><span class="o">))</span>
<span class="nv">sel2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span>E0<span class="o">)</span>,<span class="w"> </span><span class="nv">$sel1</span><span class="o">)</span>
<span class="nv">sel3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span>E1<span class="o">)</span>,<span class="w"> </span><span class="nv">$sel1</span><span class="o">)</span>
data<span class="o">([</span><span class="nv">$sel2</span>,<span class="w"> </span><span class="nv">$sel3</span><span class="o">]])</span>
</pre></div>
</div>
</section>
<section id="labnotebook">
<h3>labnotebook<a class="headerlink" href="#labnotebook" title="Link to this heading">¶</a></h3>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>labnotebook<span class="o">(</span>array<span class="w"> </span>keys<span class="o">[</span>,<span class="w"> </span>array<span class="w"> </span>selectData<span class="w"> </span><span class="o">[</span>,<span class="w"> </span>string<span class="w"> </span>entrySourceType<span class="o">]])</span>
</pre></div>
</div>
<p>The labnotebook function returns the (case insensitive) <cite>key</cite> entry from the
labnotebook for the selected channel and sweep combination(s). For selectData
either a single <cite>select</cite> or an array of select’s can be specified. If an array
is specified then over each selection is iterated independently.
The optional <cite>entrySourceType</cite> can be one of the constants <cite>DataAcqModes</cite> for data
acquisition modes as defined in <cite>../MIES/MIES_Constants.ipf</cite>. If the
<cite>entrySourceType</cite> is omitted it defaults to <cite>DATA_ACQUISITION_MODE</cite>. Wildcard
expressions using <cite>*</cite>/<cite>!</cite> are also supported. See <a class="reference internal" href="labnotebook-descriptions.html#table-numerical-labnotebook-description"><span class="std std-ref">here</span></a>
for a list of stock labnotebook entries.</p>
<p>When the optional select argument is omitted, <cite>select()</cite> is used as default
that includes all displayed sweeps and channels.</p>
<p>The <cite>labnotebook</cite> operation returns a data wave for each selected sweep/channel
combination. Each data wave contains a single element, that is depending on the
requested labnotebook entry numerical or textual.</p>
<p>When no dependent labnotebook entry could be found for the given sweep/channel
selection an independent entry is returned if available.</p>
<p>The returned data type is <cite>SF_DATATYPE_LABNOTEBOOK</cite>. If input data type is
<cite>SF_DATATYPE_SWEEP</cite> from the data operation the sweep meta data is transferred
to the returned data waves. The default suggested x-axis values for the formula
plotter are sweep numbers.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>labnotebook<span class="o">(</span>
<span class="w">   </span><span class="s2">&quot;set cycle count&quot;</span>,
<span class="w">   </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD<span class="o">))</span>,
<span class="w">   </span>DATA_ACQUISITION_MODE
<span class="o">)</span>

labnotebook<span class="o">(</span><span class="s2">&quot;*QC&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>The function searches for numeric entries in the labnotebook first and then for
text entries.</p>
</section>
<section id="anafuncparam">
<h3>anaFuncParam<a class="headerlink" href="#anafuncparam" title="Link to this heading">¶</a></h3>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>anafuncparam<span class="o">(</span>array<span class="w"> </span>keys<span class="o">[</span>,<span class="w"> </span>array<span class="w"> </span>selectData<span class="o">])</span>
</pre></div>
</div>
<p>The <cite>anafuncparam</cite> function returns the values of the requested analysis function
parameters for the selected channel and sweep combination(s). For selectData
either a single <cite>select</cite> or an array of select’s can be specified. If an array
is specified then over each selection is iterated independently.
Wildcard expressions using <cite>*</cite>/<cite>!</cite> are also supported.
See <a class="reference internal" href="analysis-function-parameters.html#table-analysis-function-parameters"><span class="std std-ref">here</span></a> for a list of parameters
from analysis functions shipped with MIES.</p>
<p>When the optional select argument is omitted, <cite>select()</cite> is used as default
that includes all displayed sweeps and channels.</p>
<p>The returned data type is <cite>SF_DATATYPE_ANAFUNCPARAM</cite>. The default suggested
x-axis values for the formula plotter are sweep numbers.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>anafuncparam<span class="o">(</span><span class="s2">&quot;SlopePercentage&quot;</span>,<span class="w"> </span><span class="k">select</span><span class="o">())</span>

anafuncparam<span class="o">([</span><span class="s2">&quot;OperationMode&quot;</span>,<span class="w"> </span><span class="s2">&quot;DA*&quot;</span><span class="o">])</span>

anafuncparam<span class="o">(</span><span class="s2">&quot;*&quot;</span><span class="o">)</span>
</pre></div>
</div>
</section>
<section id="findlevel">
<h3>findlevel<a class="headerlink" href="#findlevel" title="Link to this heading">¶</a></h3>
<p>The operation <cite>findlevel</cite> returns the x-position of the first transition to the given level.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>findlevel<span class="o">(</span>array<span class="w"> </span>data,<span class="w"> </span>variable<span class="w"> </span>level<span class="o">[</span>,<span class="w"> </span>variable<span class="w"> </span>edge<span class="o">])</span>
</pre></div>
</div>
<dl class="simple">
<dt>data</dt><dd><p>one or multiple data waves. If multiple data waves are given then the same number of data waves is returned. The operation is applied for each data wave separately.</p>
</dd>
<dt>level</dt><dd><p>level value to find</p>
</dd>
<dt>edge</dt><dd><p>defines which transition is to be found. Valid values are  rising and falling <cite>0</cite>, rising <cite>1</cite> or falling <cite>2</cite>. The default for edge is rising and falling <cite>0</cite>.</p>
</dd>
</dl>
<p>The returned data type is <cite>SF_DATATYPE_FINDLEVEL</cite>.
If input data type is <cite>SF_DATATYPE_SWEEP</cite> from the data operation the sweep meta data is transferred to the returned data waves.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>findlevel<span class="o">([</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span><span class="o">]</span>,<span class="w"> </span><span class="m">1</span>.5<span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">0</span>.5<span class="o">]</span>
</pre></div>
</div>
</section>
<section id="apfrequency">
<h3>apfrequency<a class="headerlink" href="#apfrequency" title="Link to this heading">¶</a></h3>
<p>The <cite>apfrequency</cite> operation returns the action potential frequency using the given method.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>apfrequency<span class="o">(</span>array<span class="w"> </span>data<span class="o">[</span>,<span class="w"> </span>variable<span class="w"> </span>method<span class="o">[</span>,<span class="w"> </span>variable<span class="w"> </span>level<span class="o">[</span>,<span class="w"> </span>string<span class="w"> </span>resultType<span class="o">[</span>,<span class="w"> </span>string<span class="w"> </span>normalize,<span class="o">[</span>string<span class="w"> </span>xAxisType<span class="o">]]]]])</span>
</pre></div>
</div>
<dl>
<dt>data</dt><dd><p>one or multiple data waves. If multiple data waves are given then the same number of data waves is returned. The operation is applied for each data wave separately.</p>
</dd>
<dt>method</dt><dd><p>the method can be either</p>
<ul class="simple">
<li><p><cite>0</cite> for “full”</p></li>
<li><p><cite>1</cite> for “instantaneous”</p></li>
<li><p><cite>2</cite> for apcount</p></li>
<li><p><cite>3</cite> for “instantaneous pair”</p></li>
</ul>
<p>The default method is <cite>0</cite>.</p>
</dd>
<dt>level</dt><dd><p>level threshold for peak detection. The level refers to the amplitude of the sweep(s). level is a numeric value and defaults to 0.</p>
</dd>
<dt>resultType</dt><dd><p>the result type defines what result(s) the apfrequency operation returns if the method <cite>3</cite> (instantaneous pair) is set.</p>
<ul class="simple">
<li><p><cite>time</cite> returns time intervals</p></li>
<li><p><cite>freq</cite> returns frequencies.</p></li>
</ul>
</dd>
<dt>normalize</dt><dd><p>sets the way the results get normalized</p>
<ul class="simple">
<li><p><cite>nonorm</cite>: no normalzation is applied (default)</p></li>
<li><p><cite>normoversweepsmin</cite>: normalizes over all sweeps based on the minimum result value in all sweeps based on the current method</p></li>
<li><p><cite>normoversweepsmax</cite>: normalizes over all sweeps based on the maximum result value in all sweeps based on he current method</p></li>
<li><p><cite>normoversweepsavg</cite>: normalizes over all sweeps based on the average result value in all sweeps based on the current method</p></li>
<li><p><cite>norminsweepsmin</cite>: normalizes each sweep based on the minimum result value in the specific sweep based on the current method</p></li>
<li><p><cite>norminsweepsmax</cite>: normalizes each sweep based on the maximum result value in the specific sweep based on the current method</p></li>
<li><p><cite>norminsweepsavg</cite>: normalizes each sweep based on the average result value in the specific sweep based on the current method</p></li>
</ul>
</dd>
<dt>xAxisType</dt><dd><p>if the method <cite>3</cite> (instantaneous pair) is set then xAxisType defines the x-axis of the data display.</p>
<ul class="simple">
<li><p><cite>time</cite>: the x-axis shows the occurence in time of the first peak of the pair(s), default</p></li>
<li><p><cite>count</cite>: the x-axis counts the pair(s)</p></li>
</ul>
</dd>
</dl>
<p>The basic calculation for these methods are done using the below formulas where
<span class="math notranslate nohighlight">\(l\)</span> denotes the number of found levels, <span class="math notranslate nohighlight">\(t_{i}\)</span> the timepoint in
seconds of the level and <span class="math notranslate nohighlight">\(T\)</span> the total x range of the data in seconds.</p>
<div class="math notranslate nohighlight">
\[\begin{split}f_{\text{full}}               &amp;= \frac{l}{T}                                                                   \\
f_{\text{instantaneous}}      &amp;= \frac{1}{\frac{\sum_{i = 0}^{i = l - 1} \left( t_{i + 1} - t_{i} \right)}{l}} \\
f_{\text{apcount}}            &amp;= l                                                                             \\
f_{\text{instantaneous_pair}} &amp;= \frac{1}{\left( t_{i + 1} - t_{i} \right)}\end{split}\]</div>
<p>The method <cite>2</cite> (instantaneous) and <cite>3</cite> (instantaneous pair) treat the peaks as interleaved pairs of peaks and returns results only if there are two or more peaks found.</p>
<p>The returned data type is <cite>SF_DATATYPE_APFREQUENCY</cite>. If input data type is
<cite>SF_DATATYPE_SWEEP</cite> from the data operation the sweep meta data is transferred
to the returned data waves. There is no input data verification, so it is left
to the user to select a reasonable range or epoch.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>apfrequency<span class="o">([</span><span class="m">10</span>,<span class="w"> </span><span class="m">20</span>,<span class="w"> </span><span class="m">30</span><span class="o">]</span>,<span class="w"> </span><span class="m">1</span>,<span class="w"> </span><span class="m">15</span><span class="o">)</span>

apfrequency<span class="o">(</span>data<span class="o">(</span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span>ST<span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD<span class="o">)</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">)))</span>,<span class="w"> </span><span class="m">3</span>,<span class="w"> </span><span class="m">100</span>,<span class="w"> </span>freq,<span class="w"> </span>normoversweepsavg,<span class="w"> </span>count<span class="o">)</span>

apfrequency<span class="o">(</span>data<span class="o">(</span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span>ST<span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD<span class="o">)</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">)))</span>,<span class="w"> </span><span class="m">3</span>,<span class="w"> </span><span class="m">42</span>,<span class="w"> </span>time,<span class="w"> </span>norminsweepsmin,<span class="w"> </span><span class="nb">time</span><span class="o">)</span>
</pre></div>
</div>
</section>
<section id="powerspectrum">
<h3>powerspectrum<a class="headerlink" href="#powerspectrum" title="Link to this heading">¶</a></h3>
<p>The <cite>powerspectrum</cite> operation returns the power spectrum of the input data</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>powerspectrum<span class="o">(</span>array<span class="w"> </span>data<span class="o">[</span>,<span class="w"> </span>string<span class="w"> </span>unit<span class="o">[</span>,<span class="w"> </span>string<span class="w"> </span>average<span class="o">[</span>,<span class="w"> </span>variable<span class="w"> </span>ratioFrequency<span class="o">[</span>,<span class="w"> </span>variable<span class="w"> </span>cutOffFrequency<span class="o">[</span>,<span class="w"> </span>string<span class="w"> </span>windowFunction<span class="o">]]]]])</span>
</pre></div>
</div>
<dl class="simple">
<dt>data</dt><dd><p>one or multiple data waves.</p>
</dd>
<dt>unit</dt><dd><p>the unit can be either <cite>default</cite>, <cite>dB</cite> for decibel or <cite>normalized</cite> for the spectrum normalized by its total energy. The default method is <cite>default</cite>.
<cite>default</cite> means e.g. if the signal unit is <cite>V</cite> then the y-axis unit of the power spectrum is <cite>V^2</cite>.</p>
</dd>
<dt>average</dt><dd><p>this argument allows to enable averaging over all sweeps of the same channel/channeltype combination. Possible values are <cite>avg</cite> and <cite>noavg</cite>.
The default average setting is <cite>noavg</cite>. If data waves do not originate from a sweep, then it is averaged over all of these data waves.
e.g. if there are two data waves from sweep 0,1 AD1, two data waves from sweep 0,1 AD2 and two data waves not from a sweep then
there will be three averaged waves: over all sweeps for channel combination AD1, over all sweeps for channel combination AD2 and over all data waves not from a sweep.</p>
</dd>
<dt>ratioFrequency</dt><dd><p>this argument allows to specify a frequency where the ratio between base line and signal is determined through a gaussian fit with a linear base.
A typical use is to look for line noise at 50 Hz or 60 Hz. If a non zero ratioFrequency is set then the result is a single data point per power spectrum wave.
The returned ratio is <cite>(amplitude + baseline_level) / baseline_level</cite>. The default ratioFrequency is <cite>0</cite>, that disables the ratio determination.</p>
</dd>
<dt>cutOffFrequency</dt><dd><p>The cutOffFrequency allows to limit the maximum displayed frequency of the powerspectrum. The default cutOffFrequncy is <cite>1000</cite> Hz.
The maximum cutOffFrequency is half of the sample frequency. This argument is ignored if a ratioFrequency &gt; 0 is set.</p>
</dd>
<dt>windowFunction</dt><dd><p>allows to specify the window function applied for the FFT. The default windowFunction is <cite>Hanning</cite>.
Possible options are <cite>none</cite> to disable the application of a window function and the window functions known to Igor Pro 9. See <cite>DisplayHelpTopic “FFT”</cite>.</p>
</dd>
</dl>
<p>The gaussian fit for the power ratio calculation uses the following constraints:</p>
<ul class="simple">
<li><p>The peak position must be between ratioFrequency ± 0.25 Hz</p></li>
<li><p>The maximum FWHM are 5 Hz</p></li>
<li><p>The amplitude must be &gt;= 0</p></li>
<li><p>The base of the peak must be &gt; 0</p></li>
</ul>
<p>If the fit fails a ratio of 0 is returned.</p>
<p>The returned data type is <cite>SF_DATATYPE_POWERSPECTRUM</cite>.
If input data type is <cite>SF_DATATYPE_SWEEP</cite> from the data operation and non-averaged power spectrum is calculated the sweep meta data is transferred to the returned data waves.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>powerspectrum<span class="o">(</span>data<span class="o">(</span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span>ST<span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD<span class="o">)</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">))))</span>

powerspectrum<span class="o">(</span>data<span class="o">(</span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span>ST<span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD<span class="o">)</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">)))</span>,dB,avg,0,100,HFT248D<span class="o">)</span><span class="w"> </span>//<span class="w"> </span>db<span class="w"> </span>units,<span class="w"> </span>averaging<span class="w"> </span>on,<span class="w"> </span>display<span class="w"> </span>up<span class="w"> </span>to<span class="w"> </span><span class="m">100</span><span class="w"> </span>Hz,<span class="w"> </span>use<span class="w"> </span>HFT248D<span class="w"> </span>window

powerspectrum<span class="o">(</span>data<span class="o">(</span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span>ST<span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD<span class="o">)</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">)))</span>,dB,avg,60<span class="o">)</span><span class="w"> </span>//<span class="w"> </span>db<span class="w"> </span>units,<span class="w"> </span>averaging<span class="w"> </span>on,<span class="w"> </span>determine<span class="w"> </span>power<span class="w"> </span>ratio<span class="w"> </span>at<span class="w"> </span><span class="m">60</span><span class="w"> </span>Hz
</pre></div>
</div>
</section>
<section id="psx">
<span id="sf-op-psx"></span><h3>psx<a class="headerlink" href="#psx" title="Link to this heading">¶</a></h3>
<p>The <cite>psx</cite> operation allows to classify miniature PSC/PSP’s interactively.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>psx<span class="o">(</span>id,<span class="w"> </span><span class="o">[</span>psxKernel<span class="o">()</span>,<span class="w"> </span>numSDs,<span class="w"> </span>psxSweepBPFilter<span class="o">()</span>,<span class="w"> </span>maxTauFactor,<span class="w"> </span>psxRiseTime<span class="o">()</span>,<span class="w"> </span>psxDeconvBPFilter<span class="o">()])</span>
</pre></div>
</div>
<p>The function accepts one to seven arguments.</p>
<dl class="simple">
<dt>id</dt><dd><p>identifier string, must adhere to strict igor object names.
Used for identifying the data to store/query the results wave</p>
</dd>
<dt>psxKernel</dt><dd><p>result from the <cite>psxKernel</cite> operation</p>
</dd>
<dt>numSDs</dt><dd><p>Number of standard deviations for the gaussian fit of the all points histogram, defaults to 2.5</p>
</dd>
<dt>psxSweepBPFilter</dt><dd><p>results from the <cite>psxSweepBPFilter</cite> operation</p>
</dd>
<dt>maxTauFactor</dt><dd><p>maximum tau factor, the decay tau from fitting the event must be smaller than the fit range
times maxTauFactor, defaults to 10</p>
</dd>
<dt>psxRiseTime</dt><dd><p>results from the <cite>psxRiseTime</cite> operation</p>
</dd>
<dt>psxDeconvBPFilter</dt><dd><p>results from the <cite>psxDeconvBPFilter</cite> operation</p>
</dd>
</dl>
<p>The plotting is implemented in a custom way. Due to that multiple <cite>psx</cite>
operations can only be separated by <cite>with</cite> and not <cite>and</cite>.</p>
<p>The filter order is internally made even as there is no difference in filter
order <cite>n</cite> and <cite>n + 1</cite> due to implementation details of the used operation
<cite>FilterIIR</cite>.</p>
<p>The filtering for both the sweep data and the deconvoluted data uses a backing down
algorithm for determining the filter order. The implementation starts with the
given order and decrements it by two as long as the filtering is not
successfull for all sweeps. If we reach zero we bail out. The used filter order
is stored in the wave note.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>psx<span class="o">(</span>myID<span class="o">)</span>
psx<span class="o">(</span>anotherID,<span class="w"> </span>psxkernel<span class="o">()</span>,<span class="w"> </span><span class="m">3</span>,<span class="w"> </span>psxSweepBPFilter<span class="o">(</span><span class="m">400</span>,<span class="w"> </span><span class="m">100</span><span class="o">)</span>,<span class="w"> </span><span class="m">12</span><span class="o">)</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="SweepFormula_PSX.html#sweepformula-psx"><span class="std std-ref">SweepFormula PSC/PSP classification</span></a> for an in-depth explanation of the available user
interface for acceptance/rejectance.</p>
<section id="psxkernel">
<h4>psxkernel<a class="headerlink" href="#psxkernel" title="Link to this heading">¶</a></h4>
<p>Helper operation for <cite>psx</cite> which allows to create a custom kernel and choose
the subset of data to work on.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>psxkernel<span class="o">([</span>array<span class="w"> </span>selectData,<span class="w"> </span>riseTau,<span class="w"> </span>decayTau,<span class="w"> </span>amp<span class="o">])</span>
</pre></div>
</div>
<p>The function accepts zero to four arguments.</p>
<dl class="simple">
<dt>select</dt><dd><p>selections and range to operate on from the <cite>select</cite> operation</p>
</dd>
<dt>riseTau</dt><dd><p>Time constant for kernel, defaults to 1ms</p>
</dd>
<dt>decayTau</dt><dd><p>Time constant for kernel, defaults to 15ms</p>
</dd>
<dt>amp</dt><dd><p>Amplitude for kernel, defaults to -5</p>
</dd>
</dl>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>psxkernel<span class="o">([</span><span class="m">100</span>,<span class="w"> </span><span class="m">200</span><span class="o">])</span>
psxkernel<span class="o">([</span>E0,<span class="w"> </span>E1<span class="o">])</span><span class="w"> </span><span class="c1"># list of epoch names</span>
psxkernel<span class="o">(</span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span>ST<span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD10<span class="o">)</span>,<span class="w"> </span>selsweeps<span class="o">(</span><span class="m">49</span>,<span class="w"> </span><span class="m">50</span><span class="o">)</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">))</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">13</span>,<span class="w"> </span><span class="m">2</span><span class="o">)</span>
</pre></div>
</div>
</section>
</section>
<section id="psxprep">
<h3>psxPrep<a class="headerlink" href="#psxprep" title="Link to this heading">¶</a></h3>
<p>The <cite>psxPrep</cite> operation outputs the peak threshold to be used for <cite>psx</cite> event searching.</p>
<blockquote>
<div><p>psxPrep(psx(), [numberOfSDs])</p>
</div></blockquote>
<p>The function accepts one to two arguments.</p>
<dl class="simple">
<dt>psx</dt><dd><p>results of the <cite>psx</cite> operation</p>
</dd>
<dt>numberOfSDs</dt><dd><p>Number of standard deviations of the gaussian fit to return as threshold</p>
</dd>
</dl>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>psxPrep<span class="o">(</span>psx<span class="o">(</span>psxKernel<span class="o">(</span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span>E0<span class="o">)))</span>,<span class="w"> </span><span class="m">0</span>.2,<span class="w"> </span><span class="m">400</span>,<span class="w"> </span><span class="m">100</span>,<span class="w"> </span><span class="m">12</span><span class="o">))</span>
</pre></div>
</div>
</section>
<section id="psxrisetime">
<h3>psxRiseTime<a class="headerlink" href="#psxrisetime" title="Link to this heading">¶</a></h3>
<p>The <cite>psxRiseTime</cite> operation is a helper operation for <cite>psx</cite> to manage the lower and upper thresholds for the rise time calculation
and the differential threshold for the onset time calculcation.</p>
<blockquote>
<div><p>psxRiseTime([lowerThreshold, upperThreshold, diffThreshold])</p>
</div></blockquote>
<p>The function accepts zero to two arguments.</p>
<dl class="simple">
<dt>lowerThreshold</dt><dd><p>defaults to 20%</p>
</dd>
<dt>upperThreshold</dt><dd><p>defaults to 80%</p>
</dd>
<dt>diffThreshold</dt><dd><p>defaults to 5%</p>
</dd>
</dl>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>psxRiseTime<span class="o">(</span><span class="m">0</span>.5<span class="o">)</span>
psxRiseTime<span class="o">(</span><span class="m">0</span>.5,<span class="w"> </span><span class="m">0</span>.9<span class="o">)</span>
psxRiseTime<span class="o">(</span><span class="m">0</span>.5,<span class="w"> </span><span class="m">0</span>.9,<span class="w"> </span><span class="m">0</span>.15<span class="o">)</span>
</pre></div>
</div>
</section>
<section id="psxdeconvbpfilter">
<h3>psxDeconvBPFilter<a class="headerlink" href="#psxdeconvbpfilter" title="Link to this heading">¶</a></h3>
<p>The <cite>psxDeconvBPFilter</cite> operation is a helper operation for <cite>psx</cite> to manage the deconvolution filter settings.
This filter is a bandpass filter.</p>
<blockquote>
<div><p>psxDeconvBPFilter([lowFreq, highFreq, order])</p>
</div></blockquote>
<p>The function accepts zero to three arguments.</p>
<dl class="simple">
<dt>lowFreq [Hz]</dt><dd><p>defaults to <cite>NaN</cite></p>
</dd>
<dt>highFreq [Hz]</dt><dd><p>defaults to <cite>NaN</cite></p>
</dd>
<dt>order</dt><dd><p>defaults to <cite>NaN</cite></p>
</dd>
</dl>
<p>The default values of <cite>NaN</cite> are replaced inside <cite>psx</cite>. For the order this is
<cite>4</cite>, the frequencies are calculated from rise and decay tau.
Here <cite>lowFreq</cite> is the end and <cite>highFreq</cite> the start of the
passband, see also the description of <cite>/LO</cite> and <cite>/HI</cite> from <cite>FilterIIR</cite>. If the
frequency values are not ordered correctly, they are swapped.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>psxDeconvBPFilter<span class="o">(</span><span class="m">800</span>,<span class="w"> </span><span class="m">100</span><span class="o">)</span>
psxDeconvBPFilter<span class="o">(</span><span class="m">400</span>,<span class="w"> </span><span class="m">50</span>,<span class="w"> </span><span class="m">11</span><span class="o">)</span>
</pre></div>
</div>
</section>
<section id="psxsweepbpfilter">
<h3>psxSweepBPFilter<a class="headerlink" href="#psxsweepbpfilter" title="Link to this heading">¶</a></h3>
<p>The <cite>psxSweepBPFilter</cite> operation is a helper operation for <cite>psx</cite> to manage the sweep filter settings.
This filter is a bandpass filter.</p>
<blockquote>
<div><p>psxSweepBPFilter([lowFreq, highFreq, order])</p>
</div></blockquote>
<p>The function accepts zero to three arguments.</p>
<dl class="simple">
<dt>lowFreq [Hz]</dt><dd><p>defaults to <cite>NaN</cite></p>
</dd>
<dt>highFreq [Hz]</dt><dd><p>defaults to <cite>NaN</cite></p>
</dd>
<dt>order</dt><dd><p>defaults to <cite>NaN</cite></p>
</dd>
</dl>
<p>The default values of <cite>NaN</cite> are replaced inside <cite>psx</cite>. For the order this is
<cite>4</cite>, the frequencies are calculated from rise and decay tau.
Here <cite>lowFreq</cite> is the end and <cite>highFreq</cite> the start of the
passband, see also the description of <cite>/LO</cite> and <cite>/HI</cite> from <cite>FilterIIR</cite>. If the
frequency values are not ordered correctly, they are swapped.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>psxSweepBPFilter<span class="o">(</span><span class="m">800</span>,<span class="w"> </span><span class="m">100</span><span class="o">)</span>
psxSweepBPFilter<span class="o">(</span><span class="m">400</span>,<span class="w"> </span><span class="m">50</span>,<span class="w"> </span><span class="m">11</span><span class="o">)</span>
</pre></div>
</div>
</section>
<section id="psxstats">
<h3>psxstats<a class="headerlink" href="#psxstats" title="Link to this heading">¶</a></h3>
<p>Plot properties of the result waves of a miniature PSC/PSP classification. The
operation combines the data from all input sweeps. Also all ranges for each
sweep are combined.</p>
<p>The operation allows to visualize <cite>psx</cite> data from the results wave or locally,
i.e. from an <cite>psx</cite> operation from another formula separated by <cite>and</cite>. The
local results are prefered over the results wave.</p>
<p>The traces are colored using the common headstage colors. The markers are the
same as used for visualizing the event state in <cite>psx</cite> (accepted -&gt; circle,
rejected -&gt; triangle, undetermined -&gt; square).</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>psxstats<span class="o">(</span>id,<span class="w"> </span>array<span class="w"> </span>selectData,<span class="w"> </span>prop,<span class="w"> </span>state,<span class="w"> </span><span class="o">[</span>postproc<span class="o">])</span>
</pre></div>
</div>
<p>The function accepts four or five arguments.</p>
<dl>
<dt>id</dt><dd><p>identifier string, must adhere to strict igor object names.
Used for identifying the data to query, also from the results wave</p>
</dd>
<dt>select</dt><dd><p>selections and range to operate on from the <cite>select</cite> operation</p>
</dd>
<dt>prop</dt><dd><p>column of the <cite>psx</cite> event results waves to plot.
Choices are: <cite>amp</cite>, <cite>peak</cite>, <cite>peaktime</cite>, <cite>deconvpeak</cite>, <cite>deconvpeaktime</cite>, <cite>baseline</cite>, <cite>baselinetime</cite>, <cite>xinterval</cite>,
<cite>slowtau</cite>, <cite>fasttau</cite>, <cite>weightedtau</cite>, <cite>estate</cite>, <cite>fstate</cite>, <cite>fitresult</cite>, <cite>slewrate</cite>, <cite>slewratetime</cite>, <cite>risetime</cite>, <cite>rise</cite>, <cite>onsettime</cite>, <cite>onset</cite></p>
</dd>
<dt>state</dt><dd><p>QC state to select the events.
Choices are: <cite>accept</cite>/<cite>reject</cite>/<cite>undetermined</cite>/<cite>all</cite>/<cite>every</cite></p>
<p>The used QC state depends on <cite>prop</cite>:</p>
<ul class="simple">
<li><p>Fit state QC -&gt; <cite>tau</cite>/<cite>fstate</cite>/<cite>fitresult</cite></p></li>
<li><p>Event state QC for everything else</p></li>
</ul>
<p>The difference between <cite>all</cite> and <cite>every</cite> is that <cite>all</cite> plots the events from
all possible states in <strong>one</strong> trace whereas <cite>every</cite> creates <strong>multiple</strong>
traces, one for each state.</p>
</dd>
<dt>postproc</dt><dd><p>post process the results, defaults to <cite>nothing</cite>
Choices are: <cite>nothing</cite>, <cite>stats</cite>, <cite>nonfinite</cite>, <cite>count</cite>, <cite>hist</cite>, <cite>log10</cite></p>
<dl class="simple">
<dt>nothing</dt><dd><p>no post processing</p>
</dd>
<dt>stats</dt><dd><p>calculate various statistical properties of the data</p>
</dd>
<dt>nonfinite</dt><dd><p>selects non-finite values (<cite>-inf</cite>/<cite>NaN</cite>/<cite>inf</cite>)</p>
</dd>
<dt>count</dt><dd><p>count the number of data elements</p>
</dd>
<dt>hist</dt><dd><p>create a histogram from the data</p>
</dd>
<dt>log10</dt><dd><p>apply the decadic logarithm (base 10) to each data point</p>
</dd>
</dl>
</dd>
</dl>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>psxstats<span class="o">(</span>myID,<span class="w"> </span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span><span class="m">100</span>,<span class="w"> </span><span class="m">200</span><span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD10<span class="o">)</span>,<span class="w"> </span>selsweeps<span class="o">([</span><span class="m">49</span>,<span class="w"> </span><span class="m">50</span><span class="o">])</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">))</span>,<span class="w"> </span>amp,<span class="w"> </span>accept<span class="o">)</span>
psxstats<span class="o">(</span>otherID,<span class="w"> </span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span>E0<span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD7<span class="o">)</span>,<span class="w"> </span>selsweeps<span class="o">(</span><span class="m">40</span>...60<span class="o">)</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">))</span>,<span class="w"> </span>xpos,<span class="w"> </span>every,<span class="w"> </span>log10<span class="o">)</span>
</pre></div>
</div>
</section>
<section id="fit">
<h3>fit<a class="headerlink" href="#fit" title="Link to this heading">¶</a></h3>
<p>The <cite>fit</cite> operation allows to perform a CurveFit on the given x and y data and
accepts exactly three parameters.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>fit<span class="o">(</span>arrays<span class="w"> </span>xdata,<span class="w"> </span>arrays<span class="w"> </span>ydata,<span class="w"> </span>fitOp<span class="o">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>xdata, ydata</dt><dd><p>one or multiple arrays with data</p>
</dd>
<dt>fitOp</dt><dd><p>helper operation with fit type and possible constrained parameters,
currently only <cite>fitline</cite> is available.</p>
</dd>
</dl>
<p><cite>xdata</cite> and <cite>ydata</cite> all need to be 1D, but multiple can be given. The
number of points in the corresponding x and y waves must be the same.</p>
<p>Example:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># we look at four sweeps</span>
<span class="nv">sweeps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="m">5</span>,<span class="w"> </span><span class="m">7</span>,<span class="w"> </span><span class="m">8</span>,<span class="w"> </span><span class="m">10</span><span class="o">]</span>

<span class="c1"># grab the DA data from channel 0 and epoch E1</span>
<span class="nv">selDA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>DA0<span class="o">)</span>,<span class="w"> </span>selsweeps<span class="o">(</span><span class="nv">$sweeps</span><span class="o">))</span>
<span class="nv">dDA</span><span class="w">   </span><span class="o">=</span><span class="w"> </span>data<span class="o">(</span><span class="s2">&quot;E1&quot;</span>,<span class="w"> </span><span class="nv">$selDA</span><span class="o">)</span>

<span class="c1"># E2 from AD channel 2</span>
<span class="nv">selAD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD2<span class="o">)</span>,<span class="w"> </span>selsweeps<span class="o">(</span><span class="nv">$sweeps</span><span class="o">))</span>
<span class="nv">dAD</span><span class="w">   </span><span class="o">=</span><span class="w"> </span>data<span class="o">(</span><span class="s2">&quot;E2&quot;</span>,<span class="w"> </span><span class="nv">$selAD</span><span class="o">)</span>

<span class="c1"># calculate minimum for the data in each sweep,</span>
<span class="c1"># but merge the data into one wave for the fit</span>
<span class="nv">setX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>merge<span class="o">(</span>min<span class="o">(</span><span class="nv">$dDA</span><span class="o">))</span>

<span class="c1"># and average for AD</span>
<span class="nv">setY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>merge<span class="o">(</span>avg<span class="o">(</span><span class="nv">$dAD</span><span class="o">))</span>

<span class="c1"># plot the extracted data</span>
<span class="nv">$dDA</span>

and

<span class="nv">$dAD</span>

and

<span class="c1"># and the input data</span>
<span class="nv">$setY</span><span class="w"> </span>vs<span class="w"> </span><span class="nv">$setX</span>

with

<span class="c1"># and do the fit</span>
fit<span class="o">(</span><span class="nv">$setX</span>,<span class="w"> </span><span class="nv">$setY</span>,<span class="w"> </span>fitline<span class="o">())</span>
</pre></div>
</div>
</section>
<section id="fitline">
<h3>fitline<a class="headerlink" href="#fitline" title="Link to this heading">¶</a></h3>
<p>The <cite>fitline</cite> operation allows to select a straight line for the <cite>fit</cite> and
accepts zero or one argument.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>fitline<span class="o">([</span>textarray<span class="w"> </span>constraints<span class="o">])</span>
</pre></div>
</div>
<dl class="simple">
<dt>constraints</dt><dd><p>text array with constrain definitions like <cite>K0=5</cite></p>
</dd>
</dl>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>fit<span class="o">(</span><span class="nv">$xData</span>,<span class="w"> </span><span class="nv">$yData</span>,<span class="w"> </span>fitline<span class="o">())</span>

<span class="c1"># holds the second fit parameter at 3</span>
fit<span class="o">(</span><span class="nv">$xData</span>,<span class="w"> </span><span class="nv">$yData</span>,<span class="w"> </span>fitline<span class="o">([</span><span class="s2">&quot;K1=3&quot;</span><span class="o">]))</span>
</pre></div>
</div>
</section>
</section>
<section id="utility-functions">
<h2>Utility Functions<a class="headerlink" href="#utility-functions" title="Link to this heading">¶</a></h2>
<section id="select">
<h3>select<a class="headerlink" href="#select" title="Link to this heading">¶</a></h3>
<p>The <cite>select</cite> operation allows to choose a selection of sweep data from given filter operations.
It is intended to be used with operations like <cite>data</cite>, <cite>labnotebook</cite>, <cite>epochs</cite>, <cite>tp</cite> and <cite>select</cite> itself.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">select</span><span class="o">(</span>filter,<span class="w"> </span>filter,<span class="w"> </span>...<span class="o">)</span>
</pre></div>
</div>
<p>The function accepts any number of arguments from filter operations.</p>
<p>Filter operations are <cite>selchannels</cite>, <cite>selsweeps</cite>, <cite>selrange</cite>, <cite>selvis</cite>, <cite>selscm</cite>, <cite>selstimset</cite>, <cite>selivsccsetqc</cite>, <cite>selivsccsweepqc</cite>, <cite>selexp</cite>, <cite>seldev</cite>, <cite>selrac</cite>, <cite>selsci</cite>, <cite>selsetcyclecount</cite>, <cite>selsetsweepcount</cite>, <cite>selsciindex</cite>, <cite>selracindex</cite>, <cite>select</cite>.</p>
<p>Sweeps that fit all filter criteria are taken into the selection. Each filter operation except <cite>select</cite> may appear once as argument.
It is not required that the arguments have a specific order.</p>
<p>If a specific filter is not part of the arguments and none of the arguments is a <cite>select</cite> then default values are used:
- <cite>selchannels</cite>: select all channels
- <cite>selsweeps</cite>: select all sweep numbers
- <cite>selrange</cite>: select full range
- <cite>selvis</cite>: select displayed sweeps
- <cite>selscm</cite>: select all clamp modes
- <cite>selstimset</cite>: select all stimset wave names
- <cite>selivsccsetqc</cite>: IVSCC SetQC is ignored
- <cite>selivsccsweepqc</cite>: IVSCC SweepQC is ignored
- <cite>selexp</cite>: experiment name is ignored
- <cite>seldev</cite>: device name is ignored
- <cite>selsetcyclecount</cite>: set cycle count is ignored
- <cite>selsetsweepcount</cite>: set sweep count is ignored
- <cite>selsciindex</cite>: stimset cycle id index is ignored
- <cite>selracindex</cite>: repeated acquisition is index is ignored
- <cite>selexpandrac</cite>: expansion by repeated acquisition cycle is disabled
- <cite>selexpandsci</cite>: expansion by stimset cycle id is disabled</p>
<p>If a specific filter is not part of the arguments and there exists at least one arguments that is a <cite>select</cite> then these filters will be ignored:
- <cite>selchannels</cite>: select all channels
- <cite>selsweeps</cite>: select all sweep numbers
- <cite>selrange</cite>: select full range
- <cite>selvis</cite>: select all sweeps
- <cite>selscm</cite>: select all clamp modes
- <cite>selstimset</cite>: select all stimset wave names
- <cite>selivsccsetqc</cite>: IVSCC Set QC is ignored
- <cite>selivsccsweepqc</cite>: IVSCC Sweep QC is ignored
- <cite>selexp</cite>: experiment name is ignored
- <cite>seldev</cite>: device name is ignored
- <cite>selsetcyclecount</cite>: set cycle count is ignored
- <cite>selsetsweepcount</cite>: set sweep count is ignored
- <cite>selsciindex</cite>: stimset cycle id index is ignored
- <cite>selracindex</cite>: repeated acquisition is index is ignored
- <cite>selexpandrac</cite>: expansion by repeated acquisition cycle is disabled
- <cite>selexpandsci</cite>: expansion by stimset cycle id is disabled</p>
<p>If <cite>select</cite> arguments appear multiple times then the resulting selection is an intersection of all sweep/channel combinations that were selected
from all these <cite>select</cite> arguments.
i.e. if one select argument has Sweep 0 AD0, Sweep 1 AD0 selected and a second select argument has Sweep 1 AD0 selected then
only Sweep 1 AD0 remains selected because it appears in all selections.</p>
<p>The range specified through <cite>selrange</cite> is always taken from the topmost <cite>select</cite>.</p>
<p>If an experiment is specified with a wildcard pattern through <cite>selexp</cite> then there must be only a single matching experiment. The same applies for <cite>seldev</cite>. Only when the source is from a SweepBrowser with different loaded experiments then using <cite>selexp</cite> is senseful as e.g. for a DataBrowser the experiment is always the current experiment.</p>
<p>The filter criteria of the select filters are orthogonal (independent of each other) except for <cite>selsciindex</cite>, <cite>selracindex</cite>, <cite>selexpandrac</cite> and <cite>selexpandsci</cite>.
Internally first the orthogonal select filters are applied. Then based on the resulting selections <cite>selsciindex</cite>, <cite>selracindex</cite> is applied, then <cite>selexpandsci</cite>, <cite>selexpandsci</cite>.
Intersections with additional selections from select type arguments are executed afterwards.
This implies that created selections can not be further filtered once created (see example).</p>
<p>When <cite>selexpandrac</cite> is used then the selected sweep numbers from <cite>selsweeps</cite> are extended. For each sweep selected by
<cite>selsweeps</cite> sweeps numbers of the same repeated acquisition cycle are added. For the new sweep numbers selections are gathered with a modified copy of the initial selection filter:
- <cite>selvis</cite> is changed to <cite>all</cite>
- <cite>selexp</cite> is set to the experiment of the sweep number that was extended
- <cite>seldev</cite> is set to the device of the sweep number that was extended</p>
<p>The resulting selections are gathered for each additional sweep number. Finally all selections are reduced to be unique only.</p>
<p>When <cite>selexpandsci</cite> is used then first the selection is retrieved for <cite>selsci</cite> disabled. Then for each selection
for the sweep number / channel number / channel type combination the sweep numbers with the same stimset cycle id are determined. For these sweeps selections with the same channel number / channel type are added.
Finally all selections are reduced to be unique only.</p>
<p>The expansion through <cite>selexpandsci</cite> and <cite>selexpandsci</cite> operates on the current select filter.</p>
<p>The output is composite with two datasets of different type.
The first dataset contains a N x 4 array where the columns are sweep number, channel type, GUI channel number and row index of the sweepMap. The sweepMap only exists if the window is a SweepBrowser, for DataBrowser the values are set NaN in that column.
The second dataset contains a dataset with range specification.</p>
<p>The output of the N x 4 array is sorted. The order is sweep -&gt; channel type -&gt; channel number.
e.g. for two sweeps numbered 0, 1 that have channels AD0, AD1, DA6, DA7 from a DataBrowser:
<cite>{{0, 0, 0, 0, 1, 1, 1, 1}, {0, 0, 1, 1, 0, 0, 1, 1}, {0, 1, 6, 7, 0, 1, 6, 7}, {NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN}}</cite>.</p>
<p>If the mode for <cite>selvis</cite> is <cite>displayed</cite> and no traces are displayed then a null wave is returned.
If there are no matching sweeps found a null wave is returned.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">select</span><span class="o">()</span>
<span class="k">select</span><span class="o">(</span>selvis<span class="o">(</span>all<span class="o">))</span>
<span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD4,<span class="w"> </span>DA<span class="o">)</span>,<span class="w"> </span>selsweeps<span class="o">(</span><span class="m">1</span>,<span class="w"> </span><span class="m">5</span>,<span class="w"> </span><span class="m">10</span>...16<span class="o">)</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">))</span>
<span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD2,<span class="w"> </span>DA5,<span class="w"> </span>AD0,<span class="w"> </span>DA6<span class="o">)</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">)</span>,<span class="w"> </span>selcm<span class="o">(</span>ic,<span class="w"> </span>vc<span class="o">))</span>
<span class="k">select</span><span class="o">(</span>selcm<span class="o">(</span>none<span class="o">))</span>
<span class="k">select</span><span class="o">(</span>selstimset<span class="o">(</span><span class="s2">&quot;DA_*&quot;</span>,<span class="w"> </span><span class="s2">&quot;*cell&quot;</span><span class="o">)</span>,<span class="w"> </span>selivsccsetqc<span class="o">(</span>passed<span class="o">))</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">sel1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD0<span class="o">)</span>,<span class="w"> </span>selcm<span class="o">(</span>ic<span class="o">)</span>,<span class="w"> </span>selivsccsetqc<span class="o">(</span>passed<span class="o">))</span>
<span class="nv">sel2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD0<span class="o">)</span>,<span class="w"> </span>selcm<span class="o">(</span>ic<span class="o">)</span>,<span class="w"> </span>selivsccsweepqc<span class="o">(</span>failed<span class="o">))</span>
<span class="nv">sel3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span><span class="nv">$sel1</span>,<span class="w"> </span><span class="nv">$sel2</span>,<span class="w"> </span>selrange<span class="o">(</span>cursors<span class="o">(</span>A,B<span class="o">)))</span>
<span class="nv">sel4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selsweeps<span class="o">(</span><span class="m">10</span>...1000<span class="o">)</span>,<span class="w"> </span>selrange<span class="o">([</span><span class="m">30</span>,<span class="w"> </span><span class="m">500</span><span class="o">])</span>,<span class="w"> </span><span class="nv">$sel1</span>,<span class="w"> </span><span class="nv">$sel2</span><span class="o">)</span>
<span class="nv">sel5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selsweeps<span class="o">(</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span><span class="o">)</span>,<span class="w"> </span>selrange<span class="o">(</span>E1<span class="o">)</span>,<span class="w"> </span>selstimset<span class="o">(</span><span class="s2">&quot;DA_*&quot;</span><span class="o">)</span>,<span class="w"> </span><span class="nv">$sel1</span>,<span class="w"> </span><span class="nv">$sel2</span><span class="o">)</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># For sel2 the SCI expansion applies to sweep 0, AD0. The selection result</span>
<span class="c1"># of the expansion is then intersected with sweep 1 AD0 that was selected</span>
<span class="c1"># through sel1.</span>
<span class="nv">sel1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD0<span class="o">)</span>,<span class="w"> </span>selsweeps<span class="o">(</span><span class="m">1</span><span class="o">)</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">))</span>
<span class="nv">sel2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD0<span class="o">)</span>,<span class="w"> </span>selsweeps<span class="o">(</span><span class="m">0</span><span class="o">)</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">)</span>,<span class="w"> </span>selexpandsci<span class="o">()</span>,<span class="w"> </span><span class="nv">$sel1</span><span class="o">)</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Note that the sel2 expression does not do a post-filtering of sel1</span>
<span class="c1"># instead selracindex(5) is applied to the selections resulting from</span>
<span class="c1"># the default filter setting for select for the case there is a select type argument present</span>
<span class="c1"># Then these selections are intersected from sel1</span>
<span class="c1"># Logically the intersection of the resulting selection works only for the orthogonal filter properties as a kind-of post-filter</span>
<span class="nv">sel1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selsciindex<span class="o">(</span><span class="m">3</span><span class="o">))</span>
<span class="nv">sel2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selracindex<span class="o">(</span><span class="m">5</span><span class="o">)</span>,<span class="w"> </span><span class="nv">$sel1</span><span class="o">)</span>
</pre></div>
</div>
</section>
<section id="range">
<h3>range<a class="headerlink" href="#range" title="Link to this heading">¶</a></h3>
<p>The range function is borrowed from <a class="reference external" href="https://docs.python.org/3/library/functions.html#func-range">python</a>. It expands
values into a new array.</p>
<p>This function can also be used as an operation with the “…” operator which is
the Unicode Character ‘HORIZONTAL ELLIPSIS’ (U+2026). Writing “…” is automatically converted to “…”.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>range<span class="o">(</span>variable<span class="w"> </span>start<span class="o">[</span>,<span class="w"> </span>variable<span class="w"> </span>stop<span class="o">[</span>,<span class="w"> </span>variable<span class="w"> </span>step<span class="o">]])</span>

start...stop

start…stop
</pre></div>
</div>
<p>The function generally accepts 1 to 3 arguments. The operation is intended to be
used with two arguments.</p>
<p>The returned data type is <cite>SF_DATATYPE_RANGE</cite>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>range<span class="o">(</span><span class="m">1</span>,<span class="w"> </span><span class="m">5</span>,<span class="w"> </span><span class="m">0</span>.7<span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">1</span>,<span class="w"> </span><span class="m">1</span>.7,<span class="w"> </span><span class="m">2</span>.4,<span class="w"> </span><span class="m">3</span>.1,<span class="w"> </span><span class="m">3</span>.8,<span class="w"> </span><span class="m">4</span>.5<span class="o">]</span>
range<span class="o">(</span><span class="m">3</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">0</span>,<span class="w"> </span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span><span class="o">]</span>
range<span class="o">(</span><span class="m">1</span>,<span class="w"> </span><span class="m">4</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">1</span>,<span class="w"> </span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span><span class="o">]</span>
</pre></div>
</div>
</section>
<section id="epochs">
<h3>epochs<a class="headerlink" href="#epochs" title="Link to this heading">¶</a></h3>
<p>The epochs operation returns information from epochs.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>epochs<span class="o">(</span>array<span class="w"> </span>names<span class="o">[</span>,<span class="w"> </span>array<span class="w"> </span>selectData<span class="o">[</span>,<span class="w"> </span>string<span class="w"> </span>type<span class="o">]])</span>
</pre></div>
</div>
<dl class="simple">
<dt>name</dt><dd><p>the name(s) of the epoch. The names can contain wildcard <cite>*</cite> and <cite>!</cite>.</p>
</dd>
<dt>selectData</dt><dd><dl class="simple">
<dt>the second argument is a selection of sweeps and channels where the epoch information is retrieved from. It must be specified through the <cite>select</cite> operation. Any range specification that is part of the <cite>select</cite> result is ignored.</dt><dd><p>When the optional second argument is omitted, <cite>select()</cite> is used as default that includes all displayed sweeps and channels.</p>
</dd>
</dl>
</dd>
<dt>type</dt><dd><p>sets what information is returned. Valid types are: <cite>range</cite>, <cite>name</cite> or <cite>treelevel</cite>. If type is not specified then <cite>range</cite> is used as default.</p>
</dd>
</dl>
<p>The operation returns for each selected sweep times matching epoch a data wave. The sweep meta data is transferred to the output data waves.
If there was nothing selected the number of returned data waves is zero.
If the selection contains channels that do not have epoch information stored these are skipped in the evaluation. For associated AD channels the epoch information is retrieved from the associated DA channel.
If a selection has epoch information stored in the labnotebook and the specified epoch does not exist it is skipped and thus, not included in the output waves.</p>
<p>The output data varies depending on the requested type. Multiple epochs for one
sweep always result in additional columns.</p>
<p>range:
Each output data wave is numeric and has the start/end times in the rows [ms].</p>
<p>name:
Each output data wave is textual and contains name of the epoch.</p>
<p>treelevel:
Each output data wave is numeric and has the tree level of the epoch.</p>
<p>The returned data type is <cite>SF_DATATYPE_EPOCHS</cite>.
The default suggested x-axis values for the formula plotter are sweep numbers. The suggested y-axis label is the combination of the requested type (<cite>name</cite>, <cite>tree level</cite>, <cite>range</cite>) and the epoch name wildcards.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>//<span class="w"> </span>get<span class="w"> </span>stimset<span class="w"> </span>range<span class="w"> </span><span class="o">(</span>epoch<span class="w"> </span>ST<span class="o">)</span><span class="w"> </span>from<span class="w"> </span>all<span class="w"> </span>displayed<span class="w"> </span>sweeps<span class="w"> </span>and<span class="w"> </span>channels
epochs<span class="o">(</span>ST<span class="o">)</span>

//<span class="w"> </span>two<span class="w"> </span>sweeps<span class="w"> </span>acquired<span class="w"> </span>with<span class="w"> </span>two<span class="w"> </span>headstages<span class="w"> </span><span class="nb">set</span><span class="w"> </span>with<span class="w"> </span>PulseTrain_100Hz_DA_0<span class="w"> </span>and<span class="w"> </span>PulseTrain_150Hz_DA_0<span class="w"> </span>from<span class="w"> </span>_2017_09_01_192934-compressed.nwb
epochs<span class="o">(</span>ST,<span class="w"> </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD<span class="o">))</span>,<span class="w"> </span>range<span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[[</span><span class="m">20</span>,<span class="w"> </span><span class="m">1376</span>.01<span class="o">]</span>,<span class="w"> </span><span class="o">[</span><span class="m">20</span>,<span class="w"> </span><span class="m">1342</span>.67<span class="o">]</span>,<span class="w"> </span><span class="o">[</span><span class="m">20</span>,<span class="w"> </span><span class="m">1376</span>.01<span class="o">]</span>,<span class="w"> </span><span class="o">[</span><span class="m">20</span>,<span class="w"> </span><span class="m">1342</span>.67<span class="o">]]</span>

//<span class="w"> </span>get<span class="w"> </span>stimset<span class="w"> </span>range<span class="w"> </span>from<span class="w"> </span>epochs<span class="w"> </span>starting<span class="w"> </span>with<span class="w"> </span>TP_<span class="w"> </span>and<span class="w"> </span>epochs<span class="w"> </span>starting<span class="w"> </span>with<span class="w"> </span>E<span class="w"> </span>from<span class="w"> </span>all<span class="w"> </span>displayed<span class="w"> </span>sweeps<span class="w"> </span>and<span class="w"> </span>channels
epochs<span class="o">([</span><span class="s2">&quot;TP_*&quot;</span>,<span class="w"> </span><span class="s2">&quot;E*&quot;</span><span class="o">]</span>,<span class="w"> </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD<span class="o">)))</span>

//<span class="w"> </span>get<span class="w"> </span>stimset<span class="w"> </span>range<span class="w"> </span>from<span class="w"> </span>specified<span class="w"> </span>epochs<span class="w"> </span>from<span class="w"> </span>all<span class="w"> </span>displayed<span class="w"> </span>sweeps<span class="w"> </span>and<span class="w"> </span>channels
epochs<span class="o">([</span><span class="s2">&quot;TP_B?&quot;</span>,<span class="w"> </span><span class="s2">&quot;E?_*&quot;</span><span class="o">]</span>,<span class="w"> </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD<span class="o">)))</span>

//<span class="w"> </span>get<span class="w"> </span>ranges<span class="w"> </span><span class="k">for</span><span class="w"> </span>epochs<span class="w"> </span>TP_B0/TP_B1<span class="w"> </span>where<span class="w"> </span>the<span class="w"> </span>start<span class="w"> </span>is<span class="w"> </span>offsetted<span class="w"> </span>by<span class="w"> </span><span class="m">5</span>/10<span class="w"> </span>ms
epochs<span class="o">([</span><span class="s2">&quot;TP_B0&quot;</span>,<span class="w"> </span><span class="s2">&quot;TP_B1&quot;</span><span class="o">]</span>,<span class="w"> </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD<span class="o">)))</span><span class="w"> </span>+<span class="w"> </span><span class="o">[[</span><span class="m">5</span>,<span class="w"> </span><span class="m">10</span><span class="o">]</span>,<span class="w"> </span><span class="o">[</span><span class="m">0</span>,<span class="w"> </span><span class="m">0</span><span class="o">]]</span>
</pre></div>
</div>
</section>
<section id="tp">
<h3>tp<a class="headerlink" href="#tp" title="Link to this heading">¶</a></h3>
<p>The <cite>tp</cite> operation returns analysis values for test pulses that are part of selected sweeps.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>tp<span class="o">(</span>operation<span class="w"> </span>mode<span class="o">[</span>,<span class="w"> </span>array<span class="w"> </span>selectData<span class="o">[</span>,<span class="w"> </span>array<span class="w"> </span>ignoreTPs<span class="o">]])</span>
</pre></div>
</div>
<p>The mode argument sets what test pulse analysis is run.
The following tp analysis modes are supported:</p>
<p><code class="docutils literal notranslate"><span class="pre">tpbase()</span></code> Returns the baseline level in pA or mV depending on the clamp mode.</p>
<p><code class="docutils literal notranslate"><span class="pre">tpinst()</span></code> Returns the instantaneous resistance values in MΩ.</p>
<p><code class="docutils literal notranslate"><span class="pre">tpss()</span></code> Returns the steady state resistance values in MΩ.</p>
<p><code class="docutils literal notranslate"><span class="pre">tpfit(string</span> <span class="pre">fitFunc,</span> <span class="pre">string</span> <span class="pre">retValue[,</span> <span class="pre">variable</span> <span class="pre">maxTrail])</span></code> Returns results from fitting the test pulse range.</p>
<p>See specific subsections for more details.</p>
<p>The second argument is a selection of sweeps and channels where the test pulse information is retrieved from.
It can be either a single <cite>select</cite> or an array with <cite>select`s. If an array of selects is specified then over each selection is iterated independently.
If the optional second argument is omitted, `select()</cite> is used as default that includes all displayed sweeps and channels.
Any range specification from the <cite>select</cite> is ignored when used with <cite>tp</cite>.
The <cite>tp</cite> operation pre-filters the selected sweeps, only sweeps with channel type <cite>AD</cite> are used.</p>
<p>The optional argument <code class="docutils literal notranslate"><span class="pre">ignoreTPs</span></code> allows to ignore some of the found test-pulses. The indices are zero-based and identify the
test-pulses by ascending starting time.</p>
<p>If a single sweep contains multiple test pulses then the data from the test
pulses is averaged before analysis. The included test pulses in a single sweep must have the same duration.</p>
<p>The operation returns multiple data waves. There is one data wave returned for each sweep/channel selected through selectData.
The sweep and channel meta data is included in each data wave.</p>
<p>The returned data type is <cite>SF_DATATYPE_TP</cite>.
The default suggested x-axis values for the formula plotter are sweep numbers. The suggested y-axis label is the unit of the analysis value (<cite>pA</cite>, <cite>mV</cite>, <cite>MΩ</cite>).</p>
<p>Test pulses that are part of sweeps are identified through their respective epoch short name, that starts with “TP” or “U_TP”.
If in selectData nothing is selected the number of returned data waves is zero.
If a selected sweep does not contain any test pulse then for that data wave a null wave is returned.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get steady state resistance from all displayed sweeps and channels</span>
tp<span class="o">(</span>tpss<span class="o">())</span>

<span class="c1"># Get steady state resistance from all displayed sweeps and AD channels</span>
tp<span class="o">(</span>tpss<span class="o">()</span>,<span class="w"> </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD<span class="o">)))</span>

<span class="c1"># Get base line level from all displayed sweeps and AD1 channel</span>
tp<span class="o">(</span>tpbase<span class="o">()</span>,<span class="w"> </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD1<span class="o">)))</span>

<span class="c1"># Get base line level from all displayed sweeps with AD1 channel and all sweeps with AD2 channel</span>
tp<span class="o">(</span>tpbase<span class="o">()</span>,<span class="w"> </span><span class="o">[</span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD1<span class="o">))</span>,<span class="w"> </span><span class="k">select</span><span class="o">(</span>selchannels<span class="o">(</span>AD2<span class="o">)</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">))])</span>

<span class="c1"># Get base line level from all displayed sweeps and channels ignoring test pulse 0 and 1</span>
tp<span class="o">(</span>tpbase<span class="o">()</span>,<span class="w"> </span><span class="k">select</span><span class="o">()</span>,<span class="w"> </span><span class="o">[</span><span class="m">0</span>,<span class="w"> </span><span class="m">1</span><span class="o">])</span>

<span class="c1"># Fit the test pulse from all displayed sweeps and channels exponentially and show the amplitude.</span>
tp<span class="o">(</span>tpfit<span class="o">(</span>exp,<span class="w"> </span>amp<span class="o">))</span>

<span class="c1"># Fit the test pulse from all displayed sweeps and channels double-exponentially and show the smaller tau from the two exponentials.</span>
<span class="c1"># The fitting range is changed from the default maximum of 250 ms to 500 ms if the next epoch is sufficiently long.</span>
tp<span class="o">(</span>tpfit<span class="o">(</span>doubleexp,<span class="w"> </span>tausmall,<span class="w"> </span><span class="m">500</span><span class="o">))</span>
</pre></div>
</div>
<section id="tpbase">
<h4>tpbase<a class="headerlink" href="#tpbase" title="Link to this heading">¶</a></h4>
<p>The tpbase operation specifies an operation mode for the tp operation.
In that mode the tp operation returns the baseline level in pA or mV depending on the clamp mode.
tpbase uses a fixed algorithm and takes no arguments.</p>
</section>
<section id="tpss">
<h4>tpss<a class="headerlink" href="#tpss" title="Link to this heading">¶</a></h4>
<p>The tpss operation specifies an operation mode for the tp operation.
In that mode the tp operation returns the steady state resistance values in MΩ.
tpss uses a fixed algorithm and takes no arguments.</p>
</section>
<section id="tpinst">
<h4>tpinst<a class="headerlink" href="#tpinst" title="Link to this heading">¶</a></h4>
<p>The tpinst operation specifies an operation mode for the tp operation.
In that mode the tp operation returns the instantaneous resistance values in MΩ.
tpinst uses a fixed algorithm and takes no arguments.</p>
</section>
<section id="tpfit">
<h4>tpfit<a class="headerlink" href="#tpfit" title="Link to this heading">¶</a></h4>
<p>The tpfit operation specifies an operation mode for the tp operation.
In that mode the tp operation fits data from test pulses with the specified fit function template and returns the specified fit result value.
By default the fit range includes the epoch that follows after the test pulse limited up to 250 ms. Whichever ends first. The default time limit can be overwritten with
the third argument.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>tpfit<span class="o">(</span>string<span class="w"> </span>fitFunc,<span class="w"> </span>string<span class="w"> </span>retValue<span class="o">[</span>,<span class="w"> </span>variable<span class="w"> </span>maxTrail<span class="o">])</span>
</pre></div>
</div>
<p>The first argument is the name of a fit function, valid fit functions are <code class="docutils literal notranslate"><span class="pre">exp</span></code> and <code class="docutils literal notranslate"><span class="pre">doubleexp</span></code>.
The fit function <code class="docutils literal notranslate"><span class="pre">exp</span></code> applies the fit: <span class="math notranslate nohighlight">\(y = K_0+K_1*e^{-\frac{x-x_0}{K_2}}\)</span>.
The fit function <code class="docutils literal notranslate"><span class="pre">doubleexp</span></code> applies the fit: <span class="math notranslate nohighlight">\(y = K_0+K_1*e^{-\frac{x-x_0}{K_2}}+K_3*e^{-\frac{x-x_0}{K_4}}\)</span>.</p>
<p>The second argument specifies the value returned from the fit function. Options are <code class="docutils literal notranslate"><span class="pre">tau</span></code>, <code class="docutils literal notranslate"><span class="pre">tausmall</span></code>, <code class="docutils literal notranslate"><span class="pre">amp</span></code>, <code class="docutils literal notranslate"><span class="pre">minabsamp</span></code> and <code class="docutils literal notranslate"><span class="pre">fitq</span></code>.
The option <code class="docutils literal notranslate"><span class="pre">tau</span></code> returns for the fit function <code class="docutils literal notranslate"><span class="pre">exp</span></code> the coefficient <span class="math notranslate nohighlight">\(K_2\)</span>, for <code class="docutils literal notranslate"><span class="pre">doubleexp</span></code> it returns <span class="math notranslate nohighlight">\(max(K_2, K_4)\)</span>.
The option <code class="docutils literal notranslate"><span class="pre">tausmall</span></code> returns for the fit function <code class="docutils literal notranslate"><span class="pre">exp</span></code> the coefficient <span class="math notranslate nohighlight">\(K_2\)</span>, for <code class="docutils literal notranslate"><span class="pre">doubleexp</span></code> it returns <span class="math notranslate nohighlight">\(min(K_2, K_4)\)</span>.
The option <code class="docutils literal notranslate"><span class="pre">amp</span></code> returns for the fit function <code class="docutils literal notranslate"><span class="pre">exp</span></code> the coefficient <span class="math notranslate nohighlight">\(K_1\)</span>, for <code class="docutils literal notranslate"><span class="pre">doubleexp</span></code> it returns <span class="math notranslate nohighlight">\(K_1\)</span> if <span class="math notranslate nohighlight">\(max(|K_1|, |K_3|) = |K_1|\)</span>, <span class="math notranslate nohighlight">\(K_3\)</span> otherwise.
The option <code class="docutils literal notranslate"><span class="pre">minabsamp</span></code> returns for the fit function <code class="docutils literal notranslate"><span class="pre">exp</span></code> the coefficient <span class="math notranslate nohighlight">\(K_1\)</span>, for <code class="docutils literal notranslate"><span class="pre">doubleexp</span></code> it returns <span class="math notranslate nohighlight">\(K_1\)</span> if <span class="math notranslate nohighlight">\(min(|K_1|, |K_3|) = |K_1|\)</span>, <span class="math notranslate nohighlight">\(K_3\)</span> otherwise.
The option <code class="docutils literal notranslate"><span class="pre">fitq</span></code> returns the fit quality defined as <span class="math notranslate nohighlight">\(\sum_0^n{(y_i-y_{fit})^2}/(x_n-x_0)\)</span>.</p>
<p>The optional third argument specifies the time in [ms] after the test pulse that is included in the input data for the fit.
The trail starts at the begin of the <cite>TP_B1</cite> epoch. A maxTrail value of zero refers to the end of the <cite>TP_B1</cite> epoch.
The value of maxTrail can be negative up to the begin of <cite>TP_B1</cite>.
If maxTrail is not set then the trail range ends at the beginning of the next epoch on tree level 1 or 250 ms after the end of <cite>TP_B1</cite>, whichever occurs first.</p>
</section>
</section>
<section id="log">
<h3>log<a class="headerlink" href="#log" title="Link to this heading">¶</a></h3>
<p>The <cite>log</cite> operation prints the first element of input wave to the command line but
passes the wave transparently to the next operation. It is useful for debugging
inside large formulas.</p>
<p>The operation accepts also multiple data waves as first argument.
For this case the operation is applied on each input data wave independently and returns the same number of data waves.</p>
<p>If the input wave is empty, then log prints nothing and the number of data waves returned is zero.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>//<span class="w"> </span>outputs<span class="w"> </span><span class="s2">&quot;1&quot;</span><span class="w"> </span>to<span class="w"> </span>the<span class="w"> </span><span class="nb">history</span><span class="w"> </span>area
log<span class="o">(</span><span class="m">1</span>,<span class="w"> </span><span class="m">10</span>,<span class="w"> </span><span class="m">100</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">1</span>,<span class="w"> </span><span class="m">10</span>,<span class="w"> </span><span class="m">100</span><span class="o">]</span>
</pre></div>
</div>
</section>
<section id="log10">
<h3>log10<a class="headerlink" href="#log10" title="Link to this heading">¶</a></h3>
<p>The <cite>log10</cite> operation applies the decadic (base 10) logarithm to its input.</p>
<p>The operation accepts also multiple data waves as first argument.
For this case the operation is applied on each input data wave independently and returns the same number of data waves.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>log10<span class="o">(</span><span class="m">1</span>,<span class="w"> </span><span class="m">10</span>,<span class="w"> </span><span class="m">100</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">0</span>,1,2<span class="o">]</span>
</pre></div>
</div>
</section>
<section id="store">
<h3>store<a class="headerlink" href="#store" title="Link to this heading">¶</a></h3>
<p>The <cite>store</cite> operation stores data in the labnotebook.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>store<span class="o">(</span>string<span class="w"> </span>name,<span class="w"> </span>array<span class="w"> </span>data<span class="o">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>name</dt><dd><p>name suffix for the labnotebook entry. The full entry name is  “Sweep Formula store [name]” without brackets.</p>
</dd>
<dt>data</dt><dd><p>a data wave.</p>
</dd>
</dl>
<p>The entries are written to the textual results wave for documentation purposes and
later querying. The second parameter which can be any numerical/textual array,
or output from other operations, is serialized and stored under the given name.</p>
<p>The operation returns the data argument unchanged.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>store<span class="o">(</span><span class="s2">&quot;fancy feature&quot;</span>,<span class="w"> </span><span class="o">[</span><span class="m">10</span>,<span class="w"> </span><span class="m">100</span><span class="o">])</span>
</pre></div>
</div>
<p>adds the entry “Sweep Formula store [fancy feature]” with a serialized version
of given array. The serialization format is JSON as described in the
preliminary <a class="reference external" href="https://github.com/AllenInstitute/ZeroMQ-XOP/#wave-serialization-format">specification</a>.</p>
</section>
<section id="merge">
<h3>merge<a class="headerlink" href="#merge" title="Link to this heading">¶</a></h3>
<p>The <cite>merge</cite> operation combines multiple single-point waves into a single wave
and accepts one to infinite arguments.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>merge<span class="o">(</span>array<span class="w"> </span>data1,<span class="w"> </span>array<span class="w"> </span>data2,<span class="w"> </span>...<span class="o">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>data1, data2, …</dt><dd><p>data waves (numeric and text) with only one point.</p>
</dd>
</dl>
<p>Especially useful for fitting data from operations like <cite>apfrequency</cite> which
return the data from different sweeps in separate waves.</p>
<p>The operation currently throws away all metadata.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>merge<span class="o">(</span><span class="m">4</span>,<span class="w"> </span><span class="m">7</span>,<span class="w"> </span><span class="m">8</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">4</span>,<span class="w"> </span><span class="m">7</span>,<span class="w"> </span><span class="m">8</span><span class="o">]</span>
</pre></div>
</div>
</section>
<section id="concat">
<h3>concat<a class="headerlink" href="#concat" title="Link to this heading">¶</a></h3>
<p>The concat operation allows to concatenate multiple arrays together.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>concat<span class="o">(</span>array<span class="w"> </span>data1,<span class="w"> </span>array<span class="w"> </span>data2,<span class="w"> </span>...<span class="o">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>data1, data2, …</dt><dd><p>data waves (numeric and text)</p>
</dd>
</dl>
<p>The operation accepts 1 to unlimited arguments. The dimensionality of all input
waves and their types must match.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>concat<span class="o">([</span><span class="m">1</span>,<span class="w"> </span><span class="m">5</span>,<span class="w"> </span><span class="o">[</span><span class="m">3</span>,<span class="w"> </span><span class="m">8</span><span class="o">])</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">1</span>,<span class="w"> </span><span class="m">5</span>,<span class="w"> </span><span class="m">3</span>,<span class="w"> </span><span class="m">8</span><span class="o">]</span>
concat<span class="o">([</span><span class="s2">&quot;a&quot;</span>,<span class="w"> </span><span class="s2">&quot;b], [&quot;</span>e<span class="s2">&quot;, &quot;</span>f<span class="s2">&quot;]) == [a, b, e, f]</span>
</pre></div>
</div>
</section>
<section id="dataset">
<h3>dataset<a class="headerlink" href="#dataset" title="Link to this heading">¶</a></h3>
<p>The <cite>dataset</cite> operation allows to create arbitrary datasets with any content
and accepts zero to infinite arguments.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>dataset<span class="o">(</span>array<span class="w"> </span>data1,<span class="w"> </span>array<span class="w"> </span>data2,<span class="w"> </span>...<span class="o">)</span>
</pre></div>
</div>
<dl class="simple">
<dt>data1, data2, …</dt><dd><p>data waves (numeric and text)</p>
</dd>
</dl>
<p>Useful for testing SweepFormula itself mainly.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>dataset<span class="o">(</span><span class="m">1</span>,<span class="w"> </span><span class="o">[</span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span><span class="o">]</span>,<span class="w"> </span><span class="s2">&quot;abcd&quot;</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">[</span><span class="m">1</span><span class="o">]</span>,<span class="w"> </span><span class="o">[</span><span class="m">2</span>,<span class="w"> </span><span class="m">3</span><span class="o">]</span>,<span class="w"> </span><span class="o">[</span><span class="s2">&quot;abcd]</span>
</pre></div>
</div>
</section>
<section id="table">
<h3>table<a class="headerlink" href="#table" title="Link to this heading">¶</a></h3>
<p>The <cite>table</cite> operation allows to display data in a table instead of a plot.
The operation accepts one argument. The effective result of the operation is
identical to the input argument. The change in display mode is only effective if
table is applied as outermost operation.</p>
<p>If the input is a dataset then each dataset is appended to the table.
When multiple formulas are specified with the <cite>with</cite> keyword for plotting in the same window
then the results are also appended to the table.</p>
<p>If <cite>table</cite> is applied for the y-wave expression and the <cite>vs</cite> keyword follows with an expression for the x-wave
then the expression for the x-wave is evaluated by SweepFormula but <strong>not displayed</strong> in the table.</p>
<p>The table(s) are displayed in a separate window.</p>
<p>If the input has dimension labels then these are also shown in the table.</p>
<p>When a table is active then through the context menu the formula of the results shown can be
copied to the clipboard. Multiple formulas are separated by the <cite>with</cite> keyword.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>table<span class="o">(</span>data<span class="o">(</span><span class="k">select</span><span class="o">()))</span>
</pre></div>
</div>
<p>Shows the last sweep data in a table</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>table<span class="o">(</span><span class="m">1</span><span class="o">)</span>
with
table<span class="o">(</span><span class="m">2</span><span class="o">)</span>
with
<span class="m">3</span>
and
table<span class="o">(</span><span class="m">4</span><span class="o">)</span>
</pre></div>
</div>
<p>Shows 1 and 2 in the first table, 4 in the second table and 3 in the plot window.</p>
</section>
</section>
<section id="plotting">
<h2>Plotting<a class="headerlink" href="#plotting" title="Link to this heading">¶</a></h2>
<p>When clicking the <cite>Display</cite> button in the SF tab the formula gets parsed, executed and
the result plotted. Evaluating the JSON object from the Formula Parser through the Formula Executor
gives a resulting wave.
For each data wave, the data from the rows is plotted as traces and the columns and layers
are evaluated as an array of traces. Thus, a single plotted trace is created by the following input:
<cite>1, 2, 3, 4, 5</cite>. Two traces with 5 data points each are created by this input:
<cite>[1, 3], [2, 4], [3, 5], [4, 6], [5, 7]</cite>. Whereas the input <cite>0…10, 20…30</cite> creates
ten traces with two data points each, starting with the first trace X = 0, Y = 0; X = 1, Y = 20.</p>
<p>In typical use cases instead of explicitly writing static data in the formula the data
operation is utilized that returns data in the correct layout.</p>
<p>The plotter parses the meta data from data waves as well. For suitable data types
trace colors and legend annotations are associated automatically. Operations can suggest x-values and x-axis labels to the plotter.
If the user has not specified a formula for the x-values then the plotter uses the suggested x-values instead.</p>
<p>If the formula results returns a null wave as wave reference wave an error is generated by the formula plotter.
If the formula results contains data waves that are null waves they are skipped by the formula plotter.</p>
<section id="plotting-text-waves">
<h3>Plotting Text Waves<a class="headerlink" href="#plotting-text-waves" title="Link to this heading">¶</a></h3>
<p>The formula plotter supports that the y-data or the x-data can be a 1d-text-wave. The other wave must be numeric.
2d-text-waves are not supported for plotting.</p>
</section>
<section id="separate-x-values">
<h3>Separate X-values<a class="headerlink" href="#separate-x-values" title="Link to this heading">¶</a></h3>
<p>Sometimes it is useful to explicitly specify X values for a series of data values.
Therefore, two formulas can be plotted against each other by using the vs operator.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="m">0</span>...10<span class="w"> </span>vs<span class="w"> </span>range<span class="o">(</span><span class="m">10</span>,<span class="w"> </span><span class="m">100</span>,<span class="w"> </span><span class="m">10</span><span class="o">)</span>
</pre></div>
</div>
<p>gives</p>
<figure class="align-center">
<img alt="_images/sweepFormulaPlot.svg" src="_images/sweepFormulaPlot.svg" />
</figure>
<p>Note that in this example there are 10 Y-values and only 9 X-values returned by the
respective formula part. The resulting graph shows 9 data points and thus does not show
data points where either an X or Y value for the X, Y value pair is missing.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>min<span class="o">(</span>data<span class="o">(</span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span>TP<span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD0<span class="o">)</span>,<span class="w"> </span>selsweeps<span class="o">(</span><span class="m">4</span>...11<span class="o">)</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">))))</span>
vs
<span class="m">1</span>...8
</pre></div>
</div>
<p>In the example the select operation selects channel AD0 from sweep 4, 5, 6, 7, 8, 9, 10 and 11. Thus, the data operation returns exactly 8 data waves with sweep data.
Therefore, the min operation returns 8 data waves with exactly one data point. With the specified X-wave that also contains 8 points
the first data wave from min gets the first value of the X-wave paired, the second data wave from min gets the second value of the X-wave paired a.s.o.</p>
</section>
<section id="multiple-graphs">
<h3>Multiple graphs<a class="headerlink" href="#multiple-graphs" title="Link to this heading">¶</a></h3>
<p>Several graphs can generated with a single input by separating the formulas
with <cite>and</cite>. The <cite>and</cite> must be on an own line.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="m">0</span>...10<span class="w"> </span>vs<span class="w"> </span>range<span class="o">(</span><span class="m">10</span>,<span class="w"> </span><span class="m">100</span>,<span class="w"> </span><span class="m">10</span><span class="o">)</span>
and
<span class="m">10</span>...20<span class="w"> </span>vs<span class="w"> </span>range<span class="o">(</span><span class="m">10</span>,<span class="w"> </span><span class="m">100</span>,<span class="w"> </span><span class="m">10</span><span class="o">)</span>
and
<span class="m">20</span>...30
</pre></div>
</div>
<p>The above code creates a panel with three separate graphs arranged vertically evenly spaced.</p>
<figure class="align-center">
<img alt="_images/sweepFormulaPlot4.png" src="_images/sweepFormulaPlot4.png" />
</figure>
</section>
<section id="multiple-y-formulas">
<h3>Multiple Y-Formulas<a class="headerlink" href="#multiple-y-formulas" title="Link to this heading">¶</a></h3>
<p>Several y-formulas can be plotted with the keyword <cite>with</cite>. The <cite>with</cite> must be
on an own line between the y-formulas. If the y-data contains different data
units the y-axis will show all data units separated by <cite>/</cite>. The <cite>vs</cite> allows to
set a custom x-formula for the <em>single</em> y-formula left to it. Variables, see
next section, can be used to reuse x-formulas for multiple statements without
code duplication.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">xdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>range<span class="o">(</span><span class="m">10</span>,<span class="w"> </span><span class="m">100</span>,<span class="w"> </span><span class="m">10</span><span class="o">)</span>

<span class="m">0</span>...10
with
<span class="m">20</span>...30<span class="w"> </span>vs<span class="w"> </span><span class="nv">$xdata</span>
and
<span class="m">30</span>...40
with
<span class="m">40</span>...50<span class="w"> </span>vs<span class="w"> </span><span class="nv">$xdata</span>
</pre></div>
</div>
</section>
</section>
<section id="variables">
<h2>Variables<a class="headerlink" href="#variables" title="Link to this heading">¶</a></h2>
<p>Variables store results of expressions. In formulas variables are included as strings prefixed by <cite>$</cite>.
They are specified in the lines before the formula expression. The format of a variable definition is
<cite>variableName = expression</cite>. The variable name must start with a letter. Further allowed letters are alphanumeric and <cite>_</cite>.
The variable names are treated case-insensitive.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>cursors<span class="o">(</span>A,B<span class="o">)</span>
<span class="nv">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span><span class="nv">$c</span><span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD<span class="o">)</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">))</span>

data<span class="o">(</span><span class="nv">$s</span><span class="o">)</span>
</pre></div>
</div>
<p>The section containing the variable definition can contain empty lines. The first line that is not fulfilling the format for a variable definition is treated as the first line
of the formula expression(s) section. Variable definitions can use variables that were defined in a preceding line.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>cursors<span class="o">(</span>A,B<span class="o">)</span>
<span class="nv">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span><span class="nv">$c</span><span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD<span class="o">)</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">))</span>
<span class="nv">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>data<span class="o">(</span><span class="nv">$s</span><span class="o">)</span>

<span class="nv">$d</span>
</pre></div>
</div>
<p>Previous variable content is discarded when the formula notebook is executed.</p>
<dl class="simple">
<dt>Limitations of the current variable definition concept:</dt><dd><ul class="simple">
<li><p>The expression for a variable definition is resolved to a single wave reference wave</p></li>
<li><p>A single variable can not replace multiple arguments of an operation as operation arguments are processed one-at-a-time.</p></li>
</ul>
</dd>
</dl>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># This does NOT work</span>
<span class="nv">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>cursors<span class="o">(</span>A,B<span class="o">)</span>
<span class="nv">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span><span class="nv">$c</span><span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD<span class="o">)</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">))</span>
<span class="nv">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">$s</span>,<span class="w"> </span><span class="nv">$s</span><span class="w"> </span><span class="c1"># p is resolved to a single numerical array</span>

data<span class="o">(</span><span class="nv">$p</span><span class="o">)</span><span class="w"> </span><span class="c1"># the data operation sees a single argument</span>
</pre></div>
</div>
<p>As a general rule of thumb the result of an operation is a single wave reference wave and thus valid for a variable assignment.</p>
<p>Variables are stored in the Data/SweepBrowsers data folder in the <cite>variableStorage</cite> wave.</p>
</section>
<section id="getting-quick-help">
<h2>Getting Quick Help<a class="headerlink" href="#getting-quick-help" title="Link to this heading">¶</a></h2>
<p>In the Sweep Formula notebook it is possible to get a quick help for operation and keywords like <cite>vs</cite> and <cite>and</cite>.
Mark the operation in question with the mouse and hover over it, a tooltip appears that shows the help for this operation.
Alternatively hold shift and right-click to jump to the <cite>Help</cite> tab that shows the help for the marked operation.</p>
</section>
<section id="writing-operations">
<h2>Writing Operations<a class="headerlink" href="#writing-operations" title="Link to this heading">¶</a></h2>
<p>The following sketches some templates to write an operation.</p>
<p>Generally the JSON must not be parsed by the operation itself, but the wrapper functions have to be used.</p>
<p>Steps:</p>
<ul class="simple">
<li><p>Get and check the number of arguments.</p></li>
<li><p>Retrieve and check all mandatory arguments. Use <cite>SF_GetArgument</cite> for arguments that can consist of multiple data waves and <cite>SF_GetArgumentSingle</cite> for arguments that are expected to return only a single data wave.</p></li>
<li><p>Retrieve all optional arguments from last to first and set for each a default value of not present. (see also operation code for <cite>setscale</cite>)</p></li>
<li><p>Create a output waveRef wave with <cite>SF_CreateSFRefWave</cite> of the correct size.</p></li>
<li><p>Execute the operation calculation, typically for each input data wave independently.</p></li>
<li><p>Be aware that a data wave might be a null wave, check sanity of input data wave, tranfer scales from input to calculation result if possible</p></li>
<li><p>Handle the Meta data, set a data type and transfer the wave notes on demand.</p></li>
<li><p>Return the operation result(s) through <cite>SF_GetOutputForExecutor</cite> or <cite>SF_GetOutputForExecutorSingle</cite> if the operation has only a single data wave as result.</p></li>
<li><p>Add the data type handling in <cite>SF_GetTraceColor</cite> and <cite>SF_GetMetaDataAnnotationText</cite> for proper trace colors and legend annotations in the formula plotter.</p></li>
</ul>
<p>Example code for a typical operation taking three arguments, the first argument is some kind of input data.</p>
<div class="highlight-igorpro notranslate"><div class="highlight"><pre><span></span><span class="kr">static</span><span class="w"> </span><span class="kr">Function</span>/<span class="kt">WAVE</span><span class="w"> </span>SF_OperationTemplate(<span class="kt">variable</span><span class="w"> </span>jsonId,<span class="w"> </span><span class="kt">string</span><span class="w"> </span>jsonPath,<span class="w"> </span><span class="kt">string</span><span class="w"> </span>graph)

<span class="w">       </span><span class="kt">variable</span><span class="w"> </span>numArgs
<span class="w">       </span><span class="kt">string</span><span class="w"> </span>inDataType

<span class="w">       </span>numArgs<span class="w"> </span>=<span class="w"> </span>SF_GetNumberOfArguments(jsonID,<span class="w"> </span>jsonPath)<span class="w"> </span><span class="c1">// Get number of arguments 0 to N</span>
<span class="w">       </span>SF_ASSERT(numArgs<span class="w"> </span>&lt;=3,<span class="w"> </span><span class="s">&quot;Operation has 3 arguments at most.&quot;</span>)<span class="w"> </span><span class="c1">// Check if number of arguments is correct</span>
<span class="w">       </span>SF_ASSERT(numArgs<span class="w"> </span>&gt;<span class="w"> </span>1,<span class="w"> </span><span class="s">&quot;Operation needs at least two arguments.&quot;</span>)

<span class="w">  </span><span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>arg0<span class="w"> </span>=<span class="w"> </span>SF_GetArgument(jsonID,<span class="w"> </span>jsonPath,<span class="w"> </span>graph,<span class="w"> </span>SF_OP_OPSHORTNAME,<span class="w"> </span>0)<span class="w"> </span><span class="c1">// Get first argument, this getter allows multiple data waves in the argument</span>
<span class="w">  </span><span class="c1">// For easy operation arguments it is good to have only a single argument with multiple data waves</span>

<span class="w">       </span><span class="kt">WAVE</span><span class="w"> </span>arg1<span class="w"> </span>=<span class="w"> </span>SF_GetArgumentSingle(jsonID,<span class="w"> </span>jsonPath,<span class="w"> </span>graph,<span class="w"> </span>SF_OP_OPSHORTNAME,<span class="w"> </span>1,<span class="w"> </span>checkExist=1)<span class="w"> </span><span class="c1">// Get second argument, only a single data wave is expected that must exist</span>
<span class="w">       </span>SF_ASSERT(<span class="nf">DimSize</span>(arg1,<span class="w"> </span>ROWS)<span class="w"> </span>==<span class="w"> </span>1,<span class="w"> </span><span class="s">&quot;Too many input values for argument two&quot;</span>)<span class="w"> </span><span class="c1">// Sanity checks for second argument</span>
<span class="w">       </span>SF_ASSERT(IsNumericWave(arg1),<span class="w"> </span><span class="s">&quot;opName argument two must be numeric&quot;</span>)

<span class="w">  </span><span class="c1">// Parse optional arguments from last to first</span>
<span class="w">       </span><span class="k">if</span>(numArgs<span class="w"> </span>== 3)
<span class="w">               </span><span class="kt">WAVE</span><span class="w"> </span>arg2<span class="w"> </span>=<span class="w"> </span>SF_GetArgumentSingle(jsonID,<span class="w"> </span>jsonPath,<span class="w"> </span>graph,<span class="w"> </span>SF_OP_OPSHORTNAME,<span class="w"> </span>2,<span class="w"> </span>checkExist=1)
<span class="w">               </span>SF_ASSERT(<span class="nf">DimSize</span>(arg2,<span class="w"> </span>ROWS)<span class="w"> </span>==<span class="w"> </span>1,<span class="w"> </span><span class="s">&quot;Too many input values for parameter edge&quot;</span>)
<span class="w">               </span>SF_ASSERT(IsNumericWave(arg2),<span class="w"> </span><span class="s">&quot;edge parameter must be numeric&quot;</span>)
<span class="w">       </span><span class="k">else</span>
<span class="w">     </span><span class="c1">// Set default value for optional argument if not existing</span>
<span class="w">               </span><span class="nc">Make</span>/FREE<span class="w"> </span>edge<span class="w"> </span>=<span class="w"> </span>{FINDLEVEL_EDGE_BOTH}
<span class="w">       </span><span class="k">endif</span>

<span class="w">  </span><span class="c1">// Create output wave</span>
<span class="w">       </span><span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>output<span class="w"> </span>=<span class="w"> </span>SF_CreateSFRefWave(graph,<span class="w"> </span>SF_OP_OPSHORTNAME,<span class="w"> </span><span class="nf">DimSize</span>(arg0,<span class="w"> </span>ROWS))
<span class="w">       </span>output<span class="w"> </span>=<span class="w"> </span>OperationCalculation(arg0[p],<span class="w"> </span>arg1[0],<span class="w"> </span>arg2[0])

<span class="w">  </span><span class="c1">// Handle meta data</span>
<span class="w">  </span><span class="c1">// Set data type and transfer sweep information if input data was of the correct type</span>

<span class="w">       </span>SetStringInJSONWaveNote(results,<span class="w"> </span>SF_META_DATATYPE,<span class="w"> </span>SF_DATATYPE_THISOP)
<span class="w">       </span>inDataType<span class="w"> </span>=<span class="w"> </span>GetStringFromJSONWaveNote(dataRef,<span class="w"> </span>SF_META_DATATYPE)
<span class="w">       </span><span class="k">if</span>(!<span class="nf">CmpStr</span>(inDataType,<span class="w"> </span>SF_DATATYPE_SWEEP))
<span class="w">               </span>SF_TransferFormulaDataWaveNote(arg0,<span class="w"> </span>output,<span class="w"> </span><span class="s">&quot;Sweeps&quot;</span>,<span class="w"> </span>SF_META_SWEEPNO)
<span class="w">       </span><span class="k">endif</span>

<span class="w">  </span><span class="c1">// Return multiple data waves to executor, the function will wrap the wave ref wave to a one element text wave</span>
<span class="w">       </span><span class="k">return</span><span class="w"> </span>SF_GetOutputForExecutor(results,<span class="w"> </span>graph,<span class="w"> </span>SF_OP_OPSHORTNAME)
<span class="kr">End</span>

<span class="kr">static</span><span class="w"> </span><span class="kr">Function</span>/<span class="kt">WAVE</span><span class="w"> </span>OperationCalculation(<span class="kt">WAVE</span>/Z<span class="w"> </span>input,<span class="w"> </span><span class="kt">variable</span><span class="w"> </span>arg1,<span class="w"> </span><span class="kt">variable</span><span class="w"> </span>arg2)

<span class="w">       </span><span class="k">if</span>(!<span class="nf">WaveExists</span>(input))
<span class="w">               </span><span class="k">return</span><span class="w"> </span>$<span class="s">&quot;&quot;</span>
<span class="w">       </span><span class="k">endif</span>

<span class="w">  </span><span class="c1">// Sanity checks on input data waves</span>
<span class="w">       </span>SF_ASSERT(IsNumericWave(input),<span class="w"> </span><span class="s">&quot;opname requires numeric data as input&quot;</span>)
<span class="w">       </span>SF_ASSERT(<span class="nf">WaveDims</span>(input)<span class="w"> </span>&lt;=<span class="w"> </span>2,<span class="w"> </span><span class="s">&quot;opname accepts only upto 2d data&quot;</span>)
<span class="w">       </span>SF_ASSERT(<span class="nf">DimSize</span>(input,<span class="w"> </span>ROWS)<span class="w"> </span>&gt;<span class="w"> </span>0,<span class="w"> </span><span class="s">&quot;opname requires at least one data point&quot;</span>)
<span class="w">       </span><span class="c1">// Do the actual calculation</span>
<span class="w">  </span><span class="nc">MatrixOP</span>/FREE<span class="w"> </span>out<span class="w"> </span>=<span class="w"> </span><span class="nf">sqrt</span>(averageCols(<span class="nf">magsqr</span>(input)))^t
<span class="w">  </span><span class="c1">// Transfer the scaling if possible</span>
<span class="w">       </span>SF_FormulaWaveScaleTransfer(input,<span class="w"> </span>out,<span class="w"> </span>COLS,<span class="w"> </span>ROWS)

<span class="w">       </span><span class="k">return</span><span class="w"> </span>out
<span class="kr">End</span>
</pre></div>
</div>
<p>Example code for an operation taking the top array as input data. The specific difference here is that we use a convention that if there
is only a single argument then we parse it as it could possibly an argument with multiple data waves. If it is just regular data then it is converted
to a single data wave with one element and thus, stays compatible with the <cite>SF_GetArgumentTop</cite> parsing, if that would have encountered a single element.
This allows to put output from e.g. <cite>data</cite> directly in such an operation as first argument. The operation works then on each data wave separately.</p>
<div class="highlight-igorpro notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="kr">static</span><span class="w"> </span><span class="kr">Function</span>/<span class="kt">WAVE</span><span class="w"> </span>SF_OperationTemplate(<span class="kt">variable</span><span class="w"> </span>jsonId,<span class="w"> </span><span class="kt">string</span><span class="w"> </span>jsonPath,<span class="w"> </span><span class="kt">string</span><span class="w"> </span>graph)

<span class="w">        </span><span class="kt">variable</span><span class="w"> </span>numArgs

<span class="w">        </span>numArgs<span class="w"> </span>=<span class="w"> </span>SF_GetNumberOfArguments(jsonId,<span class="w"> </span>jsonPath)
<span class="w">        </span><span class="k">if</span>(numArgs<span class="w"> </span>&gt; 1)
<span class="w">                </span><span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>input<span class="w"> </span>=<span class="w"> </span>SF_GetArgumentTop(jsonId,<span class="w"> </span>jsonPath,<span class="w"> </span>graph,<span class="w"> </span>SF_OP_OPSHORTNAME)
<span class="w">        </span><span class="k">else</span>
<span class="w">                </span><span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>input<span class="w"> </span>=<span class="w"> </span>SF_GetArgument(jsonId,<span class="w"> </span>jsonPath,<span class="w"> </span>graph,<span class="w"> </span>SF_OP_OPSHORTNAME, 0)
<span class="w">        </span><span class="k">endif</span>
<span class="w">        </span><span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>output<span class="w"> </span>=<span class="w"> </span>SF_CreateSFRefWave(graph,<span class="w"> </span>SF_OP_OPSHORTNAME,<span class="w"> </span><span class="nf">DimSize</span>(input,<span class="w"> </span>ROWS))

<span class="w">        </span>output[]<span class="w"> </span>=<span class="w"> </span>OperationCalculation(input[p])

<span class="w">        </span>SFH_TransferFormulaDataWaveNoteAndMeta(input,<span class="w"> </span>output,<span class="w"> </span>SF_OP_OPSHORTNAME,<span class="w"> </span>SF_DATATYPE_OP)

<span class="w">        </span><span class="k">return</span><span class="w"> </span>SF_GetOutputForExecutor(output,<span class="w"> </span>graph,<span class="w"> </span>SF_OP_OPSHORTNAME,<span class="w"> </span>clear=input)
<span class="kr">End</span>

<span class="kr">static</span><span class="w"> </span><span class="kr">Function</span>/<span class="kt">WAVE</span><span class="w"> </span>OperationCalculation(<span class="kt">WAVE</span>/Z<span class="w"> </span>input)

<span class="w">  </span><span class="c1">// data waves can be null</span>
<span class="w">       </span><span class="k">if</span>(!<span class="nf">WaveExists</span>(input))
<span class="w">              </span><span class="k">return</span><span class="w"> </span>$<span class="s">&quot;&quot;</span>
<span class="w">       </span><span class="k">endif</span>

<span class="w">       </span>SF_ASSERT(IsNumericWave(input),<span class="w"> </span><span class="s">&quot;opName requires numeric input data.&quot;</span>)
<span class="w">       </span>SF_ASSERT(<span class="nf">DimSize</span>(input,<span class="w"> </span>ROWS)<span class="w"> </span>&gt;<span class="w"> </span>0,<span class="w"> </span><span class="s">&quot;opName input must have at least one data point&quot;</span>)
<span class="w">  </span><span class="c1">// Do actual calculation</span>
<span class="w">       </span><span class="kt">WAVE</span><span class="w"> </span>out<span class="w"> </span>=<span class="w"> </span><span class="nf">NewFreeWave</span>(IGOR_TYPE_64BIT_FLOAT, 0)
<span class="w">       </span><span class="nc">Integrate</span>/METH=1/DIM=(ROWS)<span class="w"> </span>input/D=out
<span class="w">  </span><span class="c1">// Transfer scales and adapt</span>
<span class="w">       </span><span class="nc">CopyScales</span><span class="w"> </span>input,<span class="w"> </span>out
<span class="w">       </span><span class="nc">SetScale</span>/P<span class="w"> </span>x,<span class="w"> </span><span class="nf">DimOffset</span>(input,<span class="w"> </span>ROWS),<span class="w"> </span><span class="nf">DimDelta</span>(input,<span class="w"> </span>ROWS),<span class="w"> </span><span class="s">&quot;dx&quot;</span>,<span class="w"> </span>out

<span class="w">       </span><span class="k">return</span><span class="w"> </span>out
<span class="kr">End</span>
</pre></div>
</div>
<p>The function <cite>SFH_TransferFormulaDataWaveNoteAndMeta</cite> transfers the meta information and wave notes of the reference and data waves.
It also updates the operation stack information. There are two cases where <cite>SFH_TransferFormulaDataWaveNoteAndMeta</cite> can not be used:</p>
<ul class="simple">
<li><p>The operation does not take an input reference wave</p></li>
<li><p>The operation returns data through <cite>SF_GetOutputForExecutorSingle</cite> that creates the reference wave.</p></li>
</ul>
<p>For operations that do not take an input reference wave that is calculated to an output reference wave the approach is to update the operation stack
meta information directly through <cite>JWN_SetStringInWaveNote(output, SF_META_OPSTACK, AddListItem(SF_OP_OPSHORT, “”))</cite>.
If <cite>SF_GetOutputForExecutorSingle</cite> is called then the optional parameter <cite>opStack</cite> should be set to the previous operation stack. For operations like
<cite>selsweeps()</cite> there is no previous operation, thus the parameter would be <cite>opStack=””</cite>.</p>
<p>It should be noted that there is a difference for parsing a single first argument through <cite>SF_GetArgument</cite> or <cite>SF_GetArgumentTop</cite>.
<cite>SF_GetArgument</cite> starts execution for argument 0 specifically at the <cite>/0</cite> JSON path location, whereas <cite>SF_GetArgumentTop</cite> starts execution at <cite>/</cite>.
Set the case that the first argument is <cite>wave(pathToWave)</cite> with a 1d-wave containing a single element with value <cite>17</cite>.
<cite>SF_GetArgument</cite> executes the <cite>wave</cite> operation first, whereas <cite>SF_GetArgumentTop</cite> executes the array <cite>[wave(pathToWave)]</cite> first.
Thus, <cite>SF_GetArgument</cite> sees with the resolved <cite>wave</cite> operation <cite>[17]</cite>, whereas <cite>SF_GetArgumentTop</cite> sees <cite>[[17]]</cite>. Therefore the first returns a
<cite>{17}</cite> wave and the latter a <cite>{{17}}</cite> wave.</p>
<p>More complex operation such as <cite>data</cite> build the output wave reference wave dynamically. See <cite>SF_GetSweepsForFormula</cite> how the output wave is build depending on selectData and the found sweeps.</p>
<section id="operations-returning-a-full-plotting-specification">
<h3>Operations returning a Full Plotting Specification<a class="headerlink" href="#operations-returning-a-full-plotting-specification" title="Link to this heading">¶</a></h3>
<p>Sweep formula operations can return a result wave that is tagged as full plotting specification with the <cite>SF_META_PLOT</cite> tag. A full plotting specification
is a wave reference wave that stores formula results as if they would have been specified with the AND / WITH keyword syntax in a sweepformula notebook.
This represents an evaluated formula specification for plotting that is not yet plotted. An operation can return such full plotting specification as Y-formula
and the formula plotter will insert this in the output panel with the plots as if the formulas would have been in the sweepformula notebook.</p>
<p>The full plotting specification is a wave reference wave tree with two levels. The topmost level indexes over evaluated formula results as if
specified through the AND keyword. The second level stores evaluated formulas as if specified through the WITH keyword. For each level a wave getter is
implemented.</p>
<p>A simple operation that creates and returns a full plotting specification looks like this:</p>
<div class="highlight-igorpro notranslate"><div class="highlight"><pre><span></span><span class="kr">Function</span>/<span class="kt">WAVE</span><span class="w"> </span>FullPlottingOp(<span class="kt">STRUCT</span><span class="w"> </span>SF_ExecutionData<span class="w"> </span>&amp;exd)

<span class="w">   </span><span class="kt">string</span><span class="w"> </span>opShort<span class="w"> </span>=<span class="w"> </span>SF_OP_MYOP
<span class="w">   </span><span class="kt">string</span><span class="w"> </span>formula

<span class="w">   </span><span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>plotAND<span class="w">  </span>=<span class="w"> </span>GetFullPlottingAND(exd.graph,<span class="w"> </span>opShort, 1)
<span class="w">   </span><span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>plotWITH<span class="w"> </span>=<span class="w"> </span>GetFullPlottingWITH(1)

<span class="w">   </span>formula<span class="w">                </span>=<span class="w"> </span><span class="s">&quot;[1, 2, 3]&quot;</span>
<span class="w">   </span><span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>wvY<span class="w">          </span>=<span class="w"> </span>SFE_ExecuteFormula(formula,<span class="w"> </span>exd.graph,<span class="w"> </span>preProcess=0)
<span class="w">   </span>plotWITH[0][%FORMULAY]<span class="w"> </span>=<span class="w"> </span>wvY
<span class="w">   </span>formula<span class="w">                </span>=<span class="w"> </span><span class="s">&quot;[10, 20, 30]&quot;</span>
<span class="w">   </span><span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>wvX<span class="w">          </span>=<span class="w"> </span>SFE_ExecuteFormula(formula,<span class="w"> </span>exd.graph,<span class="w"> </span>preProcess=0)
<span class="w">   </span>plotWITH[0][%FORMULAX]<span class="w"> </span>=<span class="w"> </span>wvX
<span class="w">   </span>plotAND[0]<span class="w">             </span>=<span class="w"> </span>plotWITH

<span class="w">   </span><span class="k">return</span><span class="w"> </span>SFH_GetOutputForExecutor(plotAND,<span class="w"> </span>exd.graph,<span class="w"> </span>opShort)
<span class="kr">End</span>
</pre></div>
</div>
<p>This is equivalent to a formula of <cite>[1, 2, 3] vs [10, 20, 30]</cite>. Note that when plotAND is created the <cite>SF_META_PLOT</cite> tag is automatically set.</p>
<p>Multiple plots with AND (for simplicity no optional X-formula set here):</p>
<div class="highlight-igorpro notranslate"><div class="highlight"><pre><span></span><span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>plotAND<span class="w">  </span>=<span class="w"> </span>GetFullPlottingAND(exd.graph,<span class="w"> </span>opShort, 2)

<span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>plotWITH<span class="w">     </span>=<span class="w"> </span>GetFullPlottingWITH(1)
formula<span class="w">                </span>=<span class="w"> </span><span class="s">&quot;[1, 2, 3]&quot;</span>
<span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>wvY<span class="w">          </span>=<span class="w"> </span>SFE_ExecuteFormula(formula,<span class="w"> </span>exd.graph,<span class="w"> </span>preProcess=0)
plotWITH[0][%FORMULAY]<span class="w"> </span>=<span class="w"> </span>wvY
plotAND[0]<span class="w">             </span>=<span class="w"> </span>plotWITH

<span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>plotWITH<span class="w">     </span>=<span class="w"> </span>GetFullPlottingWITH(1)
formula<span class="w">                </span>=<span class="w"> </span><span class="s">&quot;[4, 5, 6]&quot;</span>
<span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>wvY<span class="w">          </span>=<span class="w"> </span>SFE_ExecuteFormula(formula,<span class="w"> </span>exd.graph,<span class="w"> </span>preProcess=0)
plotWITH[0][%FORMULAY]<span class="w"> </span>=<span class="w"> </span>wvY
plotAND[1]<span class="w">             </span>=<span class="w"> </span>plotWITH
</pre></div>
</div>
<p>This is equivalent to a formula of</p>
<div class="highlight-igorpro notranslate"><div class="highlight"><pre><span></span>[1, 2, 3]
and
[4, 5, 6]
</pre></div>
</div>
<p>Multiple traces with WITH (for simplicity no optional X-formula set here):</p>
<div class="highlight-igorpro notranslate"><div class="highlight"><pre><span></span><span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>plotAND<span class="w">  </span>=<span class="w"> </span>GetFullPlottingAND(exd.graph,<span class="w"> </span>opShort, 1)

<span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>plotWITH<span class="w">     </span>=<span class="w"> </span>GetFullPlottingWITH(2)
formula<span class="w">                </span>=<span class="w"> </span><span class="s">&quot;[1, 2, 3]&quot;</span>
<span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>wvY<span class="w">          </span>=<span class="w"> </span>SFE_ExecuteFormula(formula,<span class="w"> </span>exd.graph,<span class="w"> </span>preProcess=0)
plotWITH[0][%FORMULAY]<span class="w"> </span>=<span class="w"> </span>wvY
formula<span class="w">                </span>=<span class="w"> </span><span class="s">&quot;[4, 5, 6]&quot;</span>
<span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>wvY<span class="w">          </span>=<span class="w"> </span>SFE_ExecuteFormula(formula,<span class="w"> </span>exd.graph,<span class="w"> </span>preProcess=0)
plotWITH[1][%FORMULAY]<span class="w"> </span>=<span class="w"> </span>wvY
plotAND[0]<span class="w">             </span>=<span class="w"> </span>plotWITH
</pre></div>
</div>
<p>This is equivalent to a formula of</p>
<div class="highlight-igorpro notranslate"><div class="highlight"><pre><span></span>[1, 2, 3]
with
[4, 5, 6]
</pre></div>
</div>
<p>The evaluated formula result of the full plotting specification will be inserted in the formula specification of the sweep formula notebook.
For example if there is a <cite>FullPlottingOp()</cite> defined that returns <cite>[1, 2, 3]</cite> then the following sweepformula notebook code results in three plots with one trace each:</p>
<div class="highlight-igorpro notranslate"><div class="highlight"><pre><span></span>[4, 5, 6]
and
FullPlottingOp()
and
[4, 5, 6]
</pre></div>
</div>
<p>If the connection is done through <cite>with</cite> then there will be only two plots where the trace from the full plotting specification is either added to the first or
second plot, depending on if <cite>with</cite> is before or after <cite>FullPlottingOp()</cite>.</p>
<div class="highlight-igorpro notranslate"><div class="highlight"><pre><span></span>#<span class="w"> </span>two<span class="w"> </span>plots,<span class="w"> </span>first<span class="w"> </span>plot<span class="w"> </span>has<span class="w"> </span>two<span class="w"> </span>traces,<span class="w"> </span>second<span class="w"> </span>plot<span class="w"> </span>one<span class="w"> </span>trace
[4, 5, 6]
with
FullPlottingOp()
and
[4, 5, 6]

#<span class="w"> </span>upper<span class="w"> </span>code<span class="w"> </span>is<span class="w"> </span>equivalent<span class="w"> </span>to
[4, 5, 6]
with
[1, 2, 3]
and
[4, 5, 6]
</pre></div>
</div>
<div class="highlight-igorpro notranslate"><div class="highlight"><pre><span></span>#<span class="w"> </span>two<span class="w"> </span>plots,<span class="w"> </span>first<span class="w"> </span>plot<span class="w"> </span>has<span class="w"> </span>one<span class="w"> </span>trace,<span class="w"> </span>second<span class="w"> </span>plot<span class="w"> </span>two<span class="w"> </span>traces
[4, 5, 6]
and
FullPlottingOp()
with
[4, 5, 6]

#<span class="w"> </span>upper<span class="w"> </span>code<span class="w"> </span>is<span class="w"> </span>equivalent<span class="w"> </span>to
[4, 5, 6]
and
[1, 2, 3]
with
[4, 5, 6]
</pre></div>
</div>
<p>Note: If <cite>FullPlottingOp()</cite> would return more than one entry in the plotAND wave then it would itself create more plots and an <cite>with</cite> keyword
in the sweepformula notebook would only connect to the first/last plot.</p>
<p>To keep the construction of the full plotting specification simple it is recommended to put most of the formula evaluation in variables.
The evaluation call to <cite>SFE_ExecuteFormula</cite> with <cite>preProcess=0</cite> uses the current variable storage. This allows to provide already evaluated variables.
The following code snippet illustrates this:</p>
<div class="highlight-igorpro notranslate"><div class="highlight"><pre><span></span><span class="c1">// save previous variables</span>
<span class="w">     </span><span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>varStorage<span class="w"> </span>=<span class="w"> </span>GetSFVarStorage(exd.graph)
<span class="w">     </span><span class="nc">Duplicate</span>/FREE<span class="w"> </span>varStorage,<span class="w"> </span>varBackup

<span class="c1">// evaluate own variables</span>
<span class="w">     </span>formula<span class="w"> </span>=<span class="w"> </span><span class="s">&quot;var1 = 1\rvar2 = $var1 * 2&quot;</span>
<span class="w">     </span>SFE_ExecuteVariableAssignments(exd.graph,<span class="w"> </span>formula,<span class="w"> </span>allowEmptyCode<span class="w"> </span>= 1)

<span class="c1">// create plotting specification, use own variables</span>
<span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>plotAND<span class="w">      </span>=<span class="w"> </span>GetFullPlottingAND(exd.graph,<span class="w"> </span>opShort, 1)
<span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>plotWITH<span class="w">     </span>=<span class="w"> </span>GetFullPlottingWITH(1)
<span class="w">     </span>formula<span class="w">                </span>=<span class="w"> </span><span class="s">&quot;$var2&quot;</span>
<span class="w">     </span><span class="kt">WAVE</span>/<span class="kt">WAVE</span><span class="w"> </span>wvY<span class="w">          </span>=<span class="w"> </span>SFE_ExecuteFormula(formula,<span class="w"> </span>exd.graph,<span class="w"> </span>preProcess=0)
<span class="w">     </span>plotWITH[0][%FORMULAY]<span class="w"> </span>=<span class="w"> </span>wvY
plotAND[0]<span class="w">             </span>=<span class="w"> </span>plotWITH

<span class="c1">// restore previous variables</span>
<span class="nc">Duplicate</span>/O<span class="w"> </span>varBackup,<span class="w"> </span>varStorage
</pre></div>
</div>
</section>
<section id="return-operation-results-in-variable">
<h3>Return Operation Results in Variable<a class="headerlink" href="#return-operation-results-in-variable" title="Link to this heading">¶</a></h3>
<p>In some situations it is useful that the operation returns results in a variable.
This is done with the utility function <cite>SFH_AddVariableToStorage</cite>.</p>
<div class="highlight-igorpro notranslate"><div class="highlight"><pre><span></span>SFH_AddVariableToStorage(graph,<span class="w"> </span><span class="s">&quot;varName&quot;</span>,<span class="w"> </span>result)
</pre></div>
</div>
<p><cite>varName</cite> is the name of the new variable. If the variable is already present then it is replaced with the new result.
<cite>result</cite> is a wave from an evaluated formula. The utility function works on the current variable storage.
The variable content is available for all later formula evaluations.</p>
</section>
<section id="meta-data-handling">
<h3>Meta Data Handling<a class="headerlink" href="#meta-data-handling" title="Link to this heading">¶</a></h3>
<p>Operation as well as the formula plotter can evaluate returned meta data from the result wave(s). Generally meta data is set through JSON wave notes.
Data wave independent meta data is set in the wave ref wave, whereas data wave dependent data is set as note of the data wave(s) itself.
Currently certain key constants for meta data fields are defined.</p>
<p>For the wave ref wave:</p>
<ul class="simple">
<li><p>SF_META_DATATYPE: string, data type of operation result (some operations are transparent for that)</p></li>
<li><p>SF_META_XAXISLABEL: string, suggested label for the x-axis for the plotter, typically combined with x-value meta data in the data wave(s)</p></li>
<li><p>SF_META_YAXISLABEL: string, suggested label for the y-axis for the plotter</p></li>
<li><p>SF_META_OPSTACK: string, tracks the operation stack</p></li>
</ul>
<p>For the data wave(s):</p>
<ul class="simple">
<li><p>SF_META_SWEEPNO: number, number of the sweep that provided the source data</p></li>
<li><p>SF_META_CHANNELTYPE: number, channel type from the sweep that provided the source data</p></li>
<li><p>SF_META_CHANNELNUMBER: number, channel number from the sweep that provided the source data</p></li>
<li><p>SF_META_SWEEPMAPINDEX: number, index into sweepbrowser map (NaN inside the databrowser)</p></li>
<li><p>SF_META_XVALUES: wave, suggested x-wave for the plotter to display this data wave</p></li>
</ul>
<p>See also <cite>SF_OperationLabnotebookImpl</cite>, where such meta data is set.</p>
<p>The function <cite>SFH_TransferFormulaDataWaveNoteAndMeta</cite> transfers meta data from one operation to the next.
If the following conditions are met then a suggested X-values are set in the meta data:</p>
<ul class="simple">
<li><p>The input data type is SF_DATATYPE_SWEEP and all output data waves have no wave units for x set and all output data waves have only one data point -&gt; sweep number is set as X-value and “Sweeps” as x label</p></li>
<li><p>For any not above specified input data type: if all output data wave have one data point and all output data waves have no wave units for x set and the input data wave has a sweep number value set in the meta data -&gt;  sweep number is set as X-value and “Sweeps” as x label</p></li>
</ul>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>min<span class="o">(</span>
<span class="w">  </span>butterworth<span class="o">(</span>
<span class="w">    </span>integrate<span class="o">(</span>
<span class="w">      </span>derivative<span class="o">(</span>
<span class="w">        </span>data<span class="o">(</span><span class="k">select</span><span class="o">(</span>selrange<span class="o">(</span>TP<span class="o">)</span>,<span class="w"> </span>selchannels<span class="o">(</span>AD0<span class="o">)</span>,<span class="w"> </span>selsweeps<span class="o">(</span><span class="m">4</span>...11<span class="o">)</span>,<span class="w"> </span>selvis<span class="o">(</span>all<span class="o">)))</span>
<span class="w">      </span><span class="o">)</span>
<span class="w">    </span><span class="o">)</span>
<span class="w">  </span>,4,100,4<span class="o">)</span>
<span class="o">)</span>
</pre></div>
</div>
<p>In the above example the data operation sets sweep number as meta data. The <cite>SFH_TransferFormulaDataWaveNoteAndMeta</cite> function transfers that meta data also to the results of the outer operations.
The data waves returned from the min operation contain only a single data point and the result complies with the second set of conditions mentioned above. Thus, the results are
displayed in the plotter with sweep numbers on the x-axis and “Sweeps” as x-label.</p>
</section>
<section id="operation-stack">
<h3>Operation Stack<a class="headerlink" href="#operation-stack" title="Link to this heading">¶</a></h3>
<p>The operation stack meta data is updated in the called operation, typically through <cite>SFH_TransferFormulaDataWaveNoteAndMeta</cite>.
It is a semicolon separated list of operations called for a single formula, where the most recent operation is at the front of the list.
Operations where data from several sources is joined, like <cite>plus</cite> discard the previous operation stack. Thus, the operation stack contains
only operations that were relevant for the strands of data that reaches ultimately the formula plotter.
The operation stack information is used to create the trace legend(s) in the graph(s) as well as for the trace names.
Also the trace color is determined through evaluation of the operation stack. For example, only if the operation stack indicates that the most recent data
originated from a <cite>data()</cite> operation without intermediate operations that break this data strand, such as <cite>+</cite>, then the meta iformation about sweep data is taken to
determine the traces color.</p>
</section>
<section id="argument-setup-stack">
<h3>Argument Setup Stack<a class="headerlink" href="#argument-setup-stack" title="Link to this heading">¶</a></h3>
<p>The idea of the argument setup stack is to store the arguments of each operation to be able determine differences between formulas
in the end. This information can be used to change the trace style for differently setup formulas when plotted in the same graph with the
<cite>with</cite> keyword. Also in the legend it can be shown what was setup differently.
Operations can prepare argument setup information through a key/value style text wave with two columns. The wave is created with
<cite>SFH_GetNewArgSetupWave</cite> and is filled then by the operation e.g.:</p>
<div class="highlight-igorpro notranslate"><div class="highlight"><pre><span></span><span class="kt">WAVE</span>/T<span class="w"> </span>argSetup<span class="w"> </span>=<span class="w"> </span>SFH_GetNewArgSetupWave(5)

argSetup[0][%KEY]<span class="w"> </span>=<span class="w"> </span><span class="s">&quot;Method&quot;</span>
argSetup[0][%VALUE]<span class="w"> </span>=<span class="w"> </span>SF_OperationApFrequencyMethodToString(method)
argSetup[1][%KEY]<span class="w"> </span>=<span class="w"> </span><span class="s">&quot;Level&quot;</span>
argSetup[1][%VALUE]<span class="w"> </span>=<span class="w"> </span><span class="nf">num2str</span>(level)
argSetup[2][%KEY]<span class="w"> </span>=<span class="w"> </span><span class="s">&quot;ResultType&quot;</span>
argSetup[2][%VALUE]<span class="w"> </span>=<span class="w"> </span>timeFreq
argSetup[3][%KEY]<span class="w"> </span>=<span class="w"> </span><span class="s">&quot;Normalize&quot;</span>
argSetup[3][%VALUE]<span class="w"> </span>=<span class="w"> </span>normalize
argSetup[4][%KEY]<span class="w"> </span>=<span class="w"> </span><span class="s">&quot;XAxisType&quot;</span>
argSetup[4][%VALUE]<span class="w"> </span>=<span class="w"> </span>xAxisType
</pre></div>
</div>
<p>This information is stored when <cite>SFH_TransferFormulaDataWaveNoteAndMeta</cite> is called with the optional <cite>argSetup</cite> argument.
If not setup by the operation, by default the only argSetup entry is the operation short name. Thus, the information content
without setting it up is the same as in the operation stack.</p>
<p>The information is evaluated in the Formula Plotter to determine if traces from different formulas specified through the <cite>with</cite> keyword
need to be shown with a different marker or line style. It also adapts the legend to show details about differences in arguments in formulas.</p>
<div class="highlight-igorpro notranslate"><div class="highlight"><pre><span></span>apfrequency(data(select(selrange(ST),<span class="w"> </span>selchannels(AD),<span class="w"> </span>selvis(all))),<span class="w"> </span>3,<span class="w"> </span>100,<span class="w"> </span>freq,<span class="w"> </span>normoversweepsavg,<span class="w"> </span>count)
with
apfrequency(data(select(selrange(ST),<span class="w"> </span>selchannels(AD),<span class="w"> </span>selvis(all))),<span class="w"> </span>3,<span class="w"> </span>100,<span class="w"> </span><span class="nf">time</span>,<span class="w"> </span>norminsweepsavg,<span class="w"> </span>count)
</pre></div>
</div>
</section>
<section id="dynamic-operation-for-testing">
<h3>Dynamic Operation for Testing<a class="headerlink" href="#dynamic-operation-for-testing" title="Link to this heading">¶</a></h3>
<p>When <cite>AUTOMATED_TESTING</cite> is defined then the additional operation <cite>testop</cite> is available. The operation function content can be defined specifically for a test case.
The test case has to implement a non-static function with the same function signature as a sweepformula operation. Then the test case code can set
the implemented function as body for <cite>testop</cite> by updating a SVAR global:</p>
<div class="highlight-igorpro notranslate"><div class="highlight"><pre><span></span><span class="kt">SVAR</span><span class="w"> </span>funcName<span class="w"> </span>=<span class="w"> </span>$GetSFTestopName(graph)
funcName<span class="w"> </span>=<span class="w"> </span><span class="s">&quot;MySpecialTestCaseOperation&quot;</span>
</pre></div>
</div>
<p>Formulas that use <cite>testop</cite> will then execute <cite>MySpecialTestCaseOperation</cite> in that case. The global is set per SweepBrowser.</p>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="user.html">User documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="analysisbrowser.html">AnalysisBrowser</a></li>
<li class="toctree-l2"><a class="reference internal" href="databrowser.html">DataBrowser</a></li>
<li class="toctree-l2"><a class="reference internal" href="wavebuilder.html">WaveBuilder</a></li>
<li class="toctree-l2"><a class="reference internal" href="daephys.html">Da_Ephys</a></li>
<li class="toctree-l2"><a class="reference internal" href="testpulse.html">TPStorage</a></li>
<li class="toctree-l2"><a class="reference internal" href="auto_testpulse_tuning.html">Automatic test pulse tuning</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">The Sweep Formula Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#preprocessing">Preprocessing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#formula-parser">Formula Parser</a></li>
<li class="toctree-l3"><a class="reference internal" href="#formula-executor">Formula Executor</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#array-evaluation">Array Evaluation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#formula-executor-limitations">Formula Executor Limitations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#internal-data-layout">Internal Data Layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="#debugging-formula-execution">Debugging Formula Execution</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operations">Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#statistical-operations">Statistical Operations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#min-and-max">min and max</a></li>
<li class="toctree-l4"><a class="reference internal" href="#avg-and-mean">avg and mean</a></li>
<li class="toctree-l4"><a class="reference internal" href="#extract">extract</a></li>
<li class="toctree-l4"><a class="reference internal" href="#root-mean-square">root mean square</a></li>
<li class="toctree-l4"><a class="reference internal" href="#variance">variance</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stdev">stdev</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#igor-pro-wrappers">Igor Pro Wrappers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#area">area</a></li>
<li class="toctree-l4"><a class="reference internal" href="#derivative">derivative</a></li>
<li class="toctree-l4"><a class="reference internal" href="#integrate">integrate</a></li>
<li class="toctree-l4"><a class="reference internal" href="#butterworth">butterworth</a></li>
<li class="toctree-l4"><a class="reference internal" href="#xvalues-and-time">xvalues and time</a></li>
<li class="toctree-l4"><a class="reference internal" href="#setscale">setscale</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selchannels">selchannels</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selsweeps">selsweeps</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selrange">selrange</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selvis">selvis</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selcm">selcm</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selstimset">selstimset</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selexp">selexp</a></li>
<li class="toctree-l4"><a class="reference internal" href="#seldev">seldev</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selsetcyclecount">selsetcyclecount</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selsetsweepcount">selsetsweepcount</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selsciindex">selsciindex</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selracindex">selracindex</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selexpandsci">selexpandsci</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selexpandrac">selexpandrac</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selivsccsweepqc">selivsccsweepqc</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selivsccsetqc">selivsccsetqc</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cursors">cursors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wave">wave</a></li>
<li class="toctree-l4"><a class="reference internal" href="#text">text</a></li>
<li class="toctree-l4"><a class="reference internal" href="#data">data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#labnotebook">labnotebook</a></li>
<li class="toctree-l4"><a class="reference internal" href="#anafuncparam">anaFuncParam</a></li>
<li class="toctree-l4"><a class="reference internal" href="#findlevel">findlevel</a></li>
<li class="toctree-l4"><a class="reference internal" href="#apfrequency">apfrequency</a></li>
<li class="toctree-l4"><a class="reference internal" href="#powerspectrum">powerspectrum</a></li>
<li class="toctree-l4"><a class="reference internal" href="#psx">psx</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#psxkernel">psxkernel</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#psxprep">psxPrep</a></li>
<li class="toctree-l4"><a class="reference internal" href="#psxrisetime">psxRiseTime</a></li>
<li class="toctree-l4"><a class="reference internal" href="#psxdeconvbpfilter">psxDeconvBPFilter</a></li>
<li class="toctree-l4"><a class="reference internal" href="#psxsweepbpfilter">psxSweepBPFilter</a></li>
<li class="toctree-l4"><a class="reference internal" href="#psxstats">psxstats</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fit">fit</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fitline">fitline</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#utility-functions">Utility Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#select">select</a></li>
<li class="toctree-l4"><a class="reference internal" href="#range">range</a></li>
<li class="toctree-l4"><a class="reference internal" href="#epochs">epochs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tp">tp</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#tpbase">tpbase</a></li>
<li class="toctree-l5"><a class="reference internal" href="#tpss">tpss</a></li>
<li class="toctree-l5"><a class="reference internal" href="#tpinst">tpinst</a></li>
<li class="toctree-l5"><a class="reference internal" href="#tpfit">tpfit</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#log">log</a></li>
<li class="toctree-l4"><a class="reference internal" href="#log10">log10</a></li>
<li class="toctree-l4"><a class="reference internal" href="#store">store</a></li>
<li class="toctree-l4"><a class="reference internal" href="#merge">merge</a></li>
<li class="toctree-l4"><a class="reference internal" href="#concat">concat</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dataset">dataset</a></li>
<li class="toctree-l4"><a class="reference internal" href="#table">table</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#plotting">Plotting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#plotting-text-waves">Plotting Text Waves</a></li>
<li class="toctree-l4"><a class="reference internal" href="#separate-x-values">Separate X-values</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multiple-graphs">Multiple graphs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multiple-y-formulas">Multiple Y-Formulas</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#variables">Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#getting-quick-help">Getting Quick Help</a></li>
<li class="toctree-l3"><a class="reference internal" href="#writing-operations">Writing Operations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#operations-returning-a-full-plotting-specification">Operations returning a Full Plotting Specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#return-operation-results-in-variable">Return Operation Results in Variable</a></li>
<li class="toctree-l4"><a class="reference internal" href="#meta-data-handling">Meta Data Handling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#operation-stack">Operation Stack</a></li>
<li class="toctree-l4"><a class="reference internal" href="#argument-setup-stack">Argument Setup Stack</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dynamic-operation-for-testing">Dynamic Operation for Testing</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="labnotebook-descriptions.html">Labnotebook descriptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="analysis-function-parameters.html">Analysis function parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="SweepFormula_PSX.html">SweepFormula PSC/PSP classification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="developers.html">Developer</a></li>
<li class="toctree-l1"><a class="reference internal" href="reportingbugs.html">Bug reporting</a></li>
<li class="toctree-l1"><a class="reference internal" href="releasenotes.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="grouplist.html">Group list</a></li>
<li class="toctree-l1"><a class="reference internal" href="filelist.html">File list</a></li>
<li class="toctree-l1"><a class="reference internal" href="structlist.html">Struct list</a></li>
<li class="toctree-l1"><a class="reference internal" href="namespacelist.html">Namespace list</a></li>
<li class="toctree-l1"><a class="reference internal" href="todo.html">Todos</a></li>
<li class="toctree-l1"><a class="reference internal" href="deprecated.html">Deprecations</a></li>
<li class="toctree-l1"><a class="reference internal" href="CalculateTPLikePropsFromSweep.html">CalculateTPLikePropsFromSweep Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="IPNWB/Readme.html">Igor Pro module for reading and writing NeurodataWithoutBorder files</a></li>
<li class="toctree-l1"><a class="reference internal" href="TPAnalysis_algorithm.html">Testpulse Analysis Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="asyncframework.html">Async Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="labnotebook-docs.html">Labnotebook documentation for developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="epoch_information.html">Epoch Information</a></li>
<li class="toctree-l1"><a class="reference internal" href="mies-concepts.html">Important MIES concepts for developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="daq-details.html">DAQ details</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis-function-writing.html">Thirty six hints for writing analysis functions</a></li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="auto_testpulse_tuning.html"
                          title="previous chapter">Automatic test pulse tuning</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="labnotebook-descriptions.html"
                          title="next chapter">Labnotebook descriptions</a></p>
  </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="labnotebook-descriptions.html" title="Labnotebook descriptions"
             >next</a> |</li>
        <li class="right" >
          <a href="auto_testpulse_tuning.html" title="Automatic test pulse tuning"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">MIES Igor (main) Release_2.9_20250502-727-gbe223af4b documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="user.html" >User documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">The Sweep Formula Module</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright .
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div>
  </body>
</html>